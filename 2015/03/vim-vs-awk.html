<!doctype html>
<html lang="en">
    <head>
        <title>Silly Bytes</title>

        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="shortcut icon" type="image/png" href="../../img/favicon.png" />

        <link rel="stylesheet" href="../../css/default.css" />
        <link rel="stylesheet" href="../../css/post.css" />
        <link rel="stylesheet" href="../../css/about.css" />
    </head>


    <body>

        <header>
            <navbar class="navbar" role="navigation" aria-label="main navigation">
                <div class="navbar-brand">
                    <a class="navbar-item" href="../../index.html">
                        <b>Silly Bytes</b>
                    </a>
                </div>

                <div class="navbar-end">
                    <a href="../../index.html" class="navbar-item">Home</a>
                    <a href="../../about.html" class="navbar-item">About</a>
                </div>
            </navbar>
        </header>


        <div id="main" class="container is-max-desktop">
            <article class="post">
    <h1 class="is-size-2 has-text-weight-medium has-text-left">Vim vs AWK</h2>
    <aside class="date has-text-left">March  6, 2015</aside>

    <section class="post-content">
        <p>What!? Vim is a text editor and Awk a text processing scripting language, how do you even compare them!? Yes, I’m aware of it, but trust me, I have something to compare here, so take a breath and continue reading…</p>
<p>What I’m actually trying to compare here is vim scripting vs awk, still don’t make sense? Well lets take a look of this.</p>
<h1 id="study-case-vinfo">Study case: <a href="https://www.github.com/alx741/vinfo.git">Vinfo</a></h1>
<p><em>Vinfo</em> is a Vim plugin that allows you to read Info documentation files right in a vim session by converting the Info plain text files into Vim help-files so you get a nice syntax highlighting and very convenient tags for jumping between the file contents. Lets examine how it does its job.</p>
<!--more-->
<p>This is how the Info text looks like, note that the titles are underlined using <code>*</code> chars:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode markdown"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>Some context lines here</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>maybe a nice introduction</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>or something.</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Title</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>********</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>This section refer to bla bla</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>and is great because of bla bla...</span></code></pre></div>
<p>And here is what we need, with titles underlined using <code>=</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode markdown"><code class="sourceCode markdown"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Some context lines here</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>maybe a nice introduction</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>or something.</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Title</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>========</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>This section refer to bla bla</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>and is great because of bla bla...</span></code></pre></div>
<p>It appears to be a very easy task!, but its actually not.</p>
<p>Now, why is this difficult using Awk? Or even other tools like grep, sed? Or a combination of all these?</p>
<p>It’s because of the context! In the file we have other lines that starts with <code>=</code> that we don’t care about, and we are looking for the lines that starts with <code>=</code> that are under a line that starts with a number followed by a dot and followed by a word, that have a blank line separation and a paragraph above and below that are not start/end of nodes but some sort of description text. That is a difficult match!.</p>
<p>It is actually possible to do it using only Awk, but it requires code for handle the state of context, and so the code rapidly grows and increase in complexity that, we’ll see, can be easily handled using Vim script.</p>
<p>Lets see how this is done using Vim script (from Vinfo code):</p>
<pre class="vim"><code>g/\v^$\n.+\n\=+\n^$\n/norm! jjvg_r-\&lt;Esc&gt;</code></pre>
<p>On simple line that wasn’t even written from scratch, because the normal commands were obtained by doing a normal live edition on the text.</p>
<p>We could say that one of the reasons for this kind of task to become complex using Awk is because of its -per line processing- nature.</p>
<blockquote>
<p>But in Awk you can use the RS variable in order to handle multi line matches</p>
</blockquote>
<p>Yes you can, but it doesn’t mean that things will become much more easier, you’ll need to assume a constant and formatted stream of records OR dynamically change RS variable to adjust it when need it. If you have a non-homogeneous text with multi line matches and very context prone, complexity will rapidly becomes a real pain to handle.</p>
<h1 id="vim-goes-one-step-further-a-really-big-one.">Vim goes one step further (a really big one).</h1>
<p>When it comes to text processing Vim script puts a rocket under your feet!</p>
<p>You can open the target text and just start doing the edition while Vim is recording your moves (<code>:h q</code>), then you just go and paste the recorded movements in your vim-script and bang! The script code for your edition is done.</p>
<p>When writing a Awk script you need various try-fail cycles testing your regular expressions and see if you are catching what is supposed and verify if the editions are successful, nothing uncommon when programming right?</p>
<p>But in vim you can visually test all your regular expressions, make quick changes, improvements and then just paste them in the vim script when they work. And that’s nothing compared to the ability of making the changes as a normal Vim editing session and then directly putting that moves in your final script so you actually don’t even need to think “how to manipulate this to become that”, so the process is natural and pretty damn fast.</p>
<h1 id="vim-regular-expressions-engine">Vim regular expressions engine</h1>
<p>You can use a regular expression programmatically in a language like Perl for complex tasks, or you can use Vim’s regular expressions engine goodness to collapse a lot of logic into one single regex.</p>
<p>Lets say you want to process some text in the middle of a line without touching anything else in the line, you can do this in Vim by using the <code>\%V</code> atom in order to work with a visual selected area.</p>
<p>There are even expression atoms that gives you clarity, take for instance the <code>\zs</code> and <code>\ze</code> atoms that you can use instead of <code>( )</code> expression groups, it may appear not a big deal but there are situations where it’s so much clearer. Take a look of <code>:h pattern</code>.</p>
<blockquote>
<p>But, obviously, Vim is going to be slower than an Awk script</p>
</blockquote>
<p>Actually it can be, but just in a few milliseconds processing a huge file, and we really should prefer to lose a few milliseconds of processing over a few extra hours (or even days!) of Awk scripting.</p>
<blockquote>
<p>But Vim cannot handle multi threading so when executing a big text processing it hangs until it ends and I have no option but wait for it before continue working!</p>
</blockquote>
<p>That’s very truth!, BUT this will only be a problem if the text processing is meant to be executed while working in a vim session.</p>
<p>When you execute a Awk script in your shell you must wait for it to end or open a new terminal session in order to continue working. The exact same thing happens here, if you wrote a Vim script for a concrete text processing you should execute it and wait for it or get another terminal while the processing takes place (or send it to the background of course). In both cases you’ll use a terminal for the -long time- processing and then get another one for continue working, whether if it implies using Vim or not.</p>
<blockquote>
<p>But I’m not a Vim user and don’t know how to use it</p>
</blockquote>
<p>Great!, now you have a good reason for learning Vim, even if you will not use it as your main text editor :)</p>
<blockquote>
<p>So should I completely forget about Awk?</p>
</blockquote>
<p>Of course not!, Awk is an awesome tool and allows you to do awesome things, you should learn it if you don’t know it already!. I still use <em>grep</em>, <em>sed</em>, <em>tr</em>, etc to perform basic tasks, Awk will always be there to save the day. You can use it for <em>one line command</em> processing or write down a proper script if needed. Being able to use it in conjunction with other tools is great too… Which leads us to…</p>
<blockquote>
<p>Vim cannot be used in conjunction with other tools, because of its nature</p>
</blockquote>
<p>Well.. It actually can!, you just need to use the <code>-</code> (dash) option, consider the following:</p>
<pre><code>echo file | grep -i hello | vim -c scriptCommand -</code></pre>
<p>In this example <code>echo</code> pipes a “file” file into Vim, which in turn execute “scriptCommand”, and do the text processing. So notice that you can use all the mentioned tools to do big team work! Just by standard piping, because now you know you can do it with Vim!</p>
<pre><code>echo text.txt | tr ... | sed ... | awk { print $2 } | vim -c Script -</code></pre>
<h1 id="conclusion">Conclusion</h1>
<p>You shouldn’t take the title so literally and put Vim against Awk because you can still use all this tools cooperatively and conquer the <em>text</em> world :)</p>
    </section>
</article>


            <nav class="pagination is-medium">
                

                
            </nav>
        </div>

    </body>

</html>
