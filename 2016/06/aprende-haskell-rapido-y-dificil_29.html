<!doctype html>
<html lang="en">
    <head>
        <title>Silly Bytes</title>

        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="shortcut icon" type="image/png" href="../../img/favicon.png" />
        <link rel="stylesheet" href="../../css/main.css" />
    </head>


    <body>

        <header>

    <nav class="navbar">
        <div class="navbar-brand">
            <a class="navbar-item" href="../../index.html">
                <b id="logo">Silly Bytes</b>
            </a>
        </div>

        <div id="sillybytesnavbar" class="navbar-menu">
            <div class="navbar-end">
                <a href="../../index.html" class="navbar-item">Home</a>
                <a href="../../about.html" class="navbar-item">About</a>
            </div>
        </div>
    </nav>

</header>


        <div id="main" class="container is-max-desktop">
            <div class="container is-fluid">
                <article class="post">
    <h1 class="is-size-2 has-text-weight-medium has-text-left">Aprende Haskell rápido y difícil</h2>
    <aside class="date has-text-left">June 29, 2016</aside>

    <section id="post-content">
        <p>Esta es la traducción al español del artículo <a href="http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/">“Haskell the hard way”</a> por Yann Esposito.</p>
<p>TL;DR*: Un corto y denso tutorial para aprender Haskell.</p>
<p>Asómbrate con Haskell. De verdad pienso que todos los desarrolladores deberían aprender Haskell. No creo que todos necesitan convertirse en ninjas de Haskell, pero deberían al menos descubrir que es lo que Haskell tiene para ofrecer. Aprender Haskell abre tu mente.</p>
<!--more-->
<p><img src="../../img/haskellhard/thumbnail.jpg" /></p>
<p>Los lenguajes comunes comparten los mismos fundamentos:</p>
<ul>
<li>variables</li>
<li>loops</li>
<li>punteros[^1]</li>
<li>estructuras de datos, objetos y clases</li>
</ul>
<p>Haskell es muy diferente. El lenguaje usa muchos conceptos que nunca he escuchado antes. Muchos de esos conceptos te ayudarán a convertirte en un mejor programador.</p>
<p>Pero aprender Haskell puede ser difícil. Lo fue para mi. En este artículo intentaré proveer lo que me faltó durante mi aprendizaje.</p>
<p>Este artículo será ciertamente difícil de seguir. Esto es intencional. No hay atajo alguno para aprender Haskell. Es difícil y retador. Pero creo que es algo bueno. Debido a que es difícil es que Haskell es interesante.</p>
<p>El método convencional de aprender Haskell es leer dos libros. Primero <a href="http://learnyouahaskell.com/">“Learn You a Haskell”</a> y justo después <a href="http://www.realworldhaskell.org/">“Real World Haskell”</a>. También pienso que esta es la forma correcta. Pero aprender de que se trata Haskell, deberás leerlos en detalle.</p>
<p>En contraste, este artículo es un resumen muy breve y denso de los principales aspectos de Haskell. También he agregado información que a mi me faltó mientras aprendía Haskell.</p>
<p>El artículo contiene cinco partes:</p>
<ul>
<li>Introducción: un corto ejemplo para mostrar que Haskell puede ser amigable.</li>
<li>Haskell básico: sintaxis de Haskell, y algunas nociones esenciales.</li>
<li>Parte muy difícil:
<ul>
<li>Estilo funcional; un ejemplo progresivo, desde estilo imperativo al</li>
<li>funcional</li>
<li>Tipos; tipos y el ejemplo estándar del árbol binario</li>
<li>Estructuras infinitas; manipulando un árbol binario infinito!</li>
</ul></li>
<li>Parte infernalmente difícil:
<ul>
<li>Lidiar con IO; un ejemplo reducido</li>
<li>El truco de IO explicado; el detalle ocultó que yo no tuve para entender IO</li>
<li>Monads; increíble como podemos generalizar</li>
</ul></li>
<li>Apéndice:
<ul>
<li>Más sobre arboles infinitos; una discusión más matemática sobre arboles</li>
<li>infinitos</li>
</ul>
Nota: El código de ejemplo se almacena en ficheros con un nombre específico que termina en la extensión <code>.hs</code> (Haskell), y por eso en los ejemplos se escribe la ejecución de los mismos como <code>$ runhaskell   algo.hs</code> pero el nombre puede ser cualquiera.</li>
</ul>
<h1 id="introducción">Introducción</h1>
<h2 id="instalación">Instalación</h2>
<p><img src="../../img/haskellhard/shot1.jpg" /></p>
<ul>
<li><a href="https://www.haskell.org/platform/">La plataforma de Haskell</a> es la forma estándar de instalar Haskell.</li>
</ul>
<p>Herramientas:</p>
<p><code>ghc</code>: Compilador similar a <em>gcc</em> para <code>C</code>. <code>ghci</code>: Haskell interactivo (REPL) <code>runhaskell</code>: Ejecutar un programa sin compilarlo. Conveniente pero muy lento comparado a programas compilados</p>
<h2 id="no-tengas-miedo">No tengas miedo</h2>
<p><img src="../../img/haskellhard/shot2.jpg" /></p>
<p>Muchos libros/artículos sobre Haskell empiezan por introducir alguna formula esotérica (quick sort, Fibonacci, etc…). Yo lo haré justamente al revés. Al principio no mostraré ningún super poder de Haskell. Empezaré por las similaridades entre Haskell y otros lenguajes de programación. Saltemos al “Hola Mundo” obligatorio.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;Hola Mundo!&quot;</span></span></code></pre></div>
<p>Para ejecutarlo, puedes guardar el código en un fichero <code>hola.hs</code> y:</p>
<pre><code>$ runhaskell ./hola.hs
Hola Mundo!</code></pre>
<p>Ahora, un programa que pregunte tu nombre y responda “Hola” usando el nombre ingresado:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="st">&quot;Cuál es tu nombre?&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    name <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> (<span class="st">&quot;Hola &quot;</span> <span class="op">++</span> name <span class="op">++</span> <span class="st">&quot;!&quot;</span>)</span></code></pre></div>
<p>Primero, comparemos esto con programas similares en algunos lenguajes imperativos:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Python</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&quot;What is your name?&quot;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>name <span class="op">=</span> <span class="bu">raw_input</span>()</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> <span class="st">&quot;Hello </span><span class="sc">%s</span><span class="st">!&quot;</span> <span class="op">%</span> name</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Ruby</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">puts</span> <span class="st">&quot;What is your name?&quot;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>name <span class="kw">=</span> <span class="fu">gets</span><span class="at">.chomp</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="fu">puts</span> <span class="st">&quot;Hello </span><span class="sc">#{</span>name<span class="sc">}</span><span class="st">!&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// In C</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main <span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">**</span>argv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> name<span class="op">[</span><span class="dv">666</span><span class="op">];</span> <span class="co">// &lt;- An Evil Number!</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// What if my name is more than 665 character long?</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;What is your name?</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%s&quot;</span><span class="op">,</span> name<span class="op">);</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Hello %s!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> name<span class="op">);</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>La estructura es la misma, pero hay diferencias en la sintaxis. La parte principal de este tutorial será dedicada a explicar por qué.</p>
<p>En Haskell hay una función <code>main</code> y todo elemento tiene un tipo. El tipo de <code>main</code> es <code>IO ()</code>. Esto significa que <code>main</code> causará efectos secundarios.</p>
<p>Solamente recuerda que Haskell puede lucir mucho como los lenguajes imperativos populares.</p>
<h2 id="haskell-básico">Haskell básico</h2>
<p><img src="../../img/haskellhard/shot3.jpg" /></p>
<p>Antes de continuar debes ser advertido sobre algunas propiedades esenciales de Haskell.</p>
<p><strong>Funcional</strong></p>
<p>Haskell es un lenguaje funcional. Si tienes experiencia con lenguajes imperativos, deberás aprender muchas cosas nuevas. Con suerte muchos de estos nuevos conceptos te ayudarán a programas incluso en lenguajes imperativos.</p>
<p><strong>Tipado estático inteligente</strong></p>
<p>En lugar de meterse en tu camino como en <code>C</code>, <code>C++</code> o <code>Java</code>, el sistema de tipos está aquí para ayudarte.</p>
<p><strong>Pureza</strong></p>
<p>Generalmente tus funciones no modificarán nada en el mundo exterior. Esto significa que no pueden modificar el valor de una variable, no pueden obtener entrada del usuario, no pueden escribir en la pantalla, no pueden lanzar un misil. Por otro lado, el paralelismo será muy fácil de lograr. Haskell hace deja claro donde los efectos secundarios pueden ocurrir y donde el código es puro. También, será mucho más fácil razonar sobre el programa. La mayoría de los errores serán prevenidos en las partes puras del programa.</p>
<p>Además, las funciones puras siguen una ley fundamental en Haskell:</p>
<pre><code>Aplicar una funcion con los mismos parámetros siempre producirá los
mismos valores.</code></pre>
<p><strong>Perezoso (laziness)</strong></p>
<p>Laziness por defecto es un diseño de lenguaje muy poco común. Por defecto, Haskell evalúa algo solamente cuando lo necesita. En consecuencia, provee una forma muy elegante de manipular estructuras infinitas, por ejemplo.</p>
<p>Una ultima advertencia sobre como deberías leer código Haskell. Para mi, es como leer artículos científicos. Algunas partes son muy claras, pero cuando vez una formula, enfócate y lee más despacio. También, mientras se lee código Haskell, en realidad no importa mucho si no se comprenden los detalles de la sintaxis. Si encuentras algo como <code>&gt;&gt;=</code>, <code>&lt;$&gt;</code>, <code>&lt;-</code> o cualquier símbolo extraño, solamente ignóralos y continua el flujo del código.</p>
<h3 id="declaración-de-funciones">Declaración de funciones</h3>
<p>Seguramente estarás acostumbrado a funciones como:</p>
<p>En <code>C</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">*</span>x <span class="op">+</span> y<span class="op">*</span>y<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>En <code>JavaScript</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">f</span>(x<span class="op">,</span>y) {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">*</span>x <span class="op">+</span> y<span class="op">*</span>y<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>En Python:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x,y):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">*</span>x <span class="op">+</span> y<span class="op">*</span>y</span></code></pre></div>
<p>En Ruby:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> f(x,y)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    x<span class="kw">*</span>x <span class="kw">+</span> y<span class="kw">*</span>y</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>En Scheme:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(f x y)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    (<span class="op">+</span> (<span class="op">*</span> x x) (<span class="op">*</span> y y)))</span></code></pre></div>
<p>Finalmente, en Haskell es:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>f x y <span class="ot">=</span> x<span class="op">*</span>x <span class="op">+</span> y<span class="op">*</span>y</span></code></pre></div>
<p>Muy limpio. No paréntesis, no <code>def.</code></p>
<p>No olvides, Haskell usa funciones y tipos un montón. Por lo que es muy fácil definirlos. La sintaxis fuer particularmente pensada para estos elementos.</p>
<h3 id="un-ejemplo-de-tipo">Un ejemplo de tipo</h3>
<p>Aunque no es obligatorio, la información sobre los tipos para las funciones usualmente se hace explicita. No es obligatorio por que el compilador es lo bastante inteligente para descubrirlo por ti. Es una buena idea hacerlo de todas formas por que indica la intensión y facilita la comprensión.</p>
<p>Juguemos un poco. Declaramos el tipo usando <code>::</code></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>f x y <span class="ot">=</span> x<span class="op">*</span>x <span class="op">+</span> y<span class="op">*</span>y</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (f <span class="dv">2</span> <span class="dv">3</span>)</span></code></pre></div>
<pre><code>$ runhaskell 20_very_basic.lhs
13</code></pre>
<p>Ahora intenta</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>f x y <span class="ot">=</span> x<span class="op">*</span>x <span class="op">+</span> y<span class="op">*</span>y</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (f <span class="fl">2.3</span> <span class="fl">4.2</span>)</span></code></pre></div>
<p>Deberías obtener este error:</p>
<pre><code>21_very_basic.lhs:6:23:
    No instance for (Fractional Int)
    arising from the literal `4.2'
    Possible fix: add an instance declaration for (Fractional Int)
    In the second argument of `f', namely `4.2'
    In the first argument of `print', namely `(f 2.3 4.2)'
    In the expression: print (f 2.3 4.2)</code></pre>
<p>El problema: 4.2 no es un <code>Int</code>.</p>
<p>La solución: No declarar un tipo para <code>f</code> por el momento y dejar a Haskell inferir el tipo más general por nosotros:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>f x y <span class="ot">=</span> x<span class="op">*</span>x <span class="op">+</span> y<span class="op">*</span>y</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (f <span class="fl">2.3</span> <span class="fl">4.2</span>)</span></code></pre></div>
<p>Funciona! Afortunadamente, no tenemos que declarar una nueva función para cada tipo. Por ejemplo, in <code>C</code>, deberíamos declarar una función para <code>int</code>, para <code>float</code> para <code>long</code>, para <code>double</code>, etc…</p>
<p>Pero, que tipo deberíamos declarar? Para descubrir el tipo que Haskell a usado por nosotros ejecutaremos <strong>ghci</strong>:</p>
<pre><code>% ghci

GHCi, version 7.0.4: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Loading package ffi-1.0 ... linking ... done.
Prelude&gt;</code></pre>
<p>Y escribimos:</p>
<pre><code>let f x y = x*x + y*y
Prelude&gt;
:type f
f :: Num a =&gt; a -&gt; a -&gt; a</code></pre>
<p>Uh? Que es ese tipo extraño?</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>Primero, enfoquémonos en la parte de la derecha <code>a -&gt; a -&gt; a</code>. Para comprenderlo, solo mira una lista de ejemplos progresivos:</p>
<table>
<thead>
<tr class="header">
<th>El tipo</th>
<th>Su significado</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Int</td>
<td>El tipo Int</td>
</tr>
<tr class="even">
<td>Int -&gt; Int</td>
<td>El tipo de función de Int a Int</td>
</tr>
<tr class="odd">
<td>Float -&gt; Int</td>
<td>El tipo de función de Float a Int</td>
</tr>
<tr class="even">
<td>a -&gt; Int</td>
<td>El tipo de función de cualquier tipo a Int</td>
</tr>
<tr class="odd">
<td>a -&gt; a</td>
<td>El tipo de función de cualquier tipo al mismo tipo a</td>
</tr>
<tr class="even">
<td>a -&gt; a -&gt; a</td>
<td>El tipo de función de dos argumentos de cualquier tipo a al</td>
</tr>
<tr class="odd">
<td>mismo tipo a</td>
<td></td>
</tr>
</tbody>
</table>
<p>En el tipo <code>a -&gt; a -&gt; a</code>, la letra <code>a</code> es una <em>variable de tipo</em>. Significa que <code>f</code> es una función con dos argumentos y esos dos argumentos y el resultado tienen que ser del mismo tipo, La variable de tipo <code>a</code> puede ser cualquier tipo. Por ejemplo <code>Int</code>, <code>Integer</code>, <code>Float</code>…</p>
<p>Así que en lugar de forzar un tipo en particular como en <code>C</code> y tener que declarar una función para <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, etc., podemos declarar una sola función como en un lenguaje de tipado dinámico.</p>
<p>Esto es algunas veces llamado polimorfismo paramétrico.</p>
<p>Generalmente <code>a</code> puede ser cualquier tipo, por ejemplo un <code>String</code> a un <code>Int</code>, pero también puede ser tipos más complejos, como <code>Trees</code>, otras funciones, etc. Pero en este caso nuestro tipo tiene como prefijo <code>Num a =&gt;</code>.</p>
<p><code>Num</code> es una <em>clase de tipo</em> (type class). Una clase de tipo puede ser vista como un conjunto de tipos. <code>Num</code> contiene solamente los tipos que pueden comportarse como números. Más concretamente, <code>Num</code> es una clase que contiene tipos que implementan una lista especifica de funciones, en particular <code>(+)</code> y <code>(*)</code>.</p>
<p>Las clases de tipos son un aspecto muy potente del lenguaje. Podemos hacer cosas increíbles con esto. Más sobre el tema luego.</p>
<p>Finalmente, <code>Num a =&gt; a -&gt; a -&gt; a</code> significa:</p>
<p>Sea <code>a</code> un tipo que pertenece a la clase de tipo <code>Num</code>. Esto es una función de tipo <code>a</code> a (<code>a -&gt; a</code>).</p>
<p>Si, extraño. De hecho, en Haskell ninguna función tiene dos argumentos. En lugar de eso todas las funciones pueden tener un solo argumento. Pero notaremos que tomar dos argumentos es equivalente a tomar un argumento y retornar una función que toma el segundo argumento como parámetro.</p>
<p>Más concretamente <code>f 3 4</code> es equivalente a <code>(f 3) 4</code>. Nótese que <code>f 3</code> es una función:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>g <span class="ot">=</span> f <span class="dv">3</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>g y ⇔ <span class="dv">3</span><span class="op">*</span><span class="dv">3</span> <span class="op">+</span> y<span class="op">*</span>y</span></code></pre></div>
<p>Existe otra notación para funciones. La notación <em>lambda</em> nos permite crear funciones sin asignarles un nombre. Llamamos a estas funciones anónimas. Podemos escribirlas como:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>g <span class="ot">=</span> \y <span class="ot">-&gt;</span> <span class="dv">3</span><span class="op">*</span><span class="dv">3</span> <span class="op">+</span> y<span class="op">*</span>y</span></code></pre></div>
<p>El <code>\\</code> es usado por que se parece a <code>λ</code> (símbolo lambda) y es ASCII.</p>
<p>Si no estás acostumbrado a la programación funcional tu cerebro debería estar empezando a calentarse. Es tiempo de hacer una aplicación real.</p>
<p>Pero antes de eso, deberíamos verificar que el sistema de tipos funciona según lo esperado.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>f x y <span class="ot">=</span> x<span class="op">*</span>x <span class="op">+</span> y<span class="op">*</span>y</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (f <span class="dv">3</span> <span class="fl">2.4</span>)</span></code></pre></div>
<p>Funciona, porque, <code>3</code> es una representación valida para números fraccionarios como <code>Float</code> así como para <code>Integer</code>. Como <code>2.4</code> es una numero fraccionario, <code>3</code> es interpretado también como un numero fraccionario.</p>
<p>Si forzamos nuestra función a trabajar con tipos diferentes, fallará.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>f x y <span class="ot">=</span> x<span class="op">*</span>x <span class="op">+</span> y<span class="op">*</span>y</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="ot">x ::</span> <span class="dt">Int</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">3</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="ot">y ::</span> <span class="dt">Float</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>y <span class="ot">=</span> <span class="fl">2.4</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- No funcionará por que el tipo x ≠ tipo y</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (f x y)</span></code></pre></div>
<p>El compilador se queja. Los dos parámetros deben ser del mismo tipo.</p>
<p>Si piensas que esto es una mala idea, y que el compilador debería hacer la transformación de un tipo al otro por ti, deberías ver este fantástico (y divertido) vídeo: <a href="https://www.destroyallsoftware.com/talks/wat">WAT</a></p>
<h1 id="haskell-esencial">Haskell esencial</h1>
<p><img src="../../img/haskellhard/shot4.jpg" /></p>
<p>Sugiero que leas con ligereza esta parte. Mírala como una referencia. Haskell tiene un montón de características. Regresa aquí cada vez que la notación te parezca extraña.</p>
<p>Uso el símbolo <code>⇔</code> para indicar que dos expresiones son equivalentes. Es una meta notación, <code>⇔</code> no existe en Haskell. También usaré <code>⇒</code> para indicar cual es el valor de retorno de una expresión.</p>
<h2 id="notaciones">Notaciones</h2>
<p><strong>Aritmética</strong></p>
<pre><code>3 + 2 * 6 / 3 ⇔ 3 + ((2*6)/3)</code></pre>
<p><strong>Lógica</strong></p>
<pre><code>True || False ⇒ True
True &amp;&amp; False ⇒ False
True == False ⇒ False
True /= False ⇒ True  (/=) es el operador diferencia</code></pre>
<p><strong>Potencias</strong></p>
<pre><code>x^n     para un n entero (Int o Integer)
x**y    para cualquier tipo de numero y (como un Float)</code></pre>
<p><code>Integer</code> no tiene ningún limite además de la capacidad de tu máquina.</p>
<pre><code>4^103
102844034832575377634685573909834406561420991602098741459288064</code></pre>
<p>Si! También hay números racionales! Pero hay que importar el modulo <code>Data.Ratio</code>:</p>
<pre><code>$ ghci
....
Prelude&gt; :m Data.Ratio
Data.Ratio&gt; (11 % 15) * (5 % 3)
11 % 9</code></pre>
<p><strong>Listas</strong></p>
<pre><code>[]                      ⇔ Lista vacia
[1,2,3]                 ⇔ Lista de enteros
[&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]     ⇔ Lista de cadenas
1:[2,3]                 ⇔ [1,2,3], (:) anteponer un elemento
1:2:[]                  ⇔ [1,2]
[1,2] ++ [3,4]          ⇔ [1,2,3,4], (++) concatenar
[1,2,3] ++ [&quot;foo&quot;]      ⇔ ERROR String ≠ Integral
[1..4]                  ⇔ [1,2,3,4]
[1,3..10]               ⇔ [1,3,5,7,9]
[2,3,5,7,11..100]       ⇔ ERROR! No soy tan inteligente!
[10,9..1]               ⇔ [10,9,8,7,6,5,4,3,2,1]</code></pre>
<p><strong>Cadenas</strong></p>
<p>En Haskell las cadenas son listas de <code>Char</code>.</p>
<pre><code>'a' :: Char
&quot;a&quot; :: [Char]
&quot;&quot;  ⇔ []
&quot;ab&quot; ⇔ ['a','b'] ⇔  'a':&quot;b&quot; ⇔ 'a':['b'] ⇔ 'a':'b':[]
&quot;abc&quot; ⇔ &quot;ab&quot;++&quot;c&quot;


En código real no se debería usar una lista de `Char` para
representar texto. Se debería usar `Data.Text`. Si quieres
representar un flujo de caracteres ASCII, deberías usar
`Data.ByteString`.</code></pre>
<p><strong>Tuplas</strong></p>
<p>El tipo de una tupla es <code>(a,b)</code>. Los elementos dentro de una tupla pueden tener diferentes tipos.</p>
<pre><code>-- Todas estas tuplas son validas
(2,&quot;foo&quot;)
(3,'a',[2,3])
((2,&quot;a&quot;),&quot;c&quot;,3)

fst (x,y)       ⇒  x
snd (x,y)       ⇒  y

fst (x,y,z)     ⇒  ERROR: fst :: (a,b) -&gt; a
snd (x,y,z)     ⇒  ERROR: snd :: (a,b) -&gt; b</code></pre>
<p><strong>Controlar los paréntesis</strong></p>
<p>Para remover algunos paréntesis se pueden usar dos funciones: <code>($)</code> y <code>(.)</code>.</p>
<pre><code>-- Por defecto:
f g h x         ⇔  (((f g) h) x)

-- el $ reemplaza los paréntessis desde el $
-- hasta el final de la expresión
f g $ h x       ⇔  f g (h x) ⇔ (f g) (h x)
f $ g h x       ⇔  f (g h x) ⇔ f ((g h) x)
f $ g $ h x     ⇔  f (g (h x))

-- (.) composición de funciones
(f . g) x       ⇔  f (g x)
(f . g . h) x   ⇔  f (g (h x))</code></pre>
<h2 id="notaciones-útiles-para-funciones">Notaciones útiles para funciones</h2>
<p>Solo un recordatorio:</p>
<pre><code>x :: Int            ⇔ x es de tipo Int
x :: a              ⇔ x puede ser de cualquier tipo
x :: Num a =&gt; a     ⇔ x puede ser cualquier tipo a
                    que pertenezca a la class de typo Num
f :: a -&gt; b         ⇔ f es una función de a hacia b
f :: a -&gt; b -&gt; c    ⇔ f es una función de a hacia (b→c)
f :: (a -&gt; b) -&gt; c  ⇔ f es una función de (a→b) hacia c</code></pre>
<p>Recuerda que definir el tipo de una función antes de su declaración no es obligatorio. Haskell infiere el tipo más general por ti. Pero es considerado una buena practica hacerlo de todos modos.</p>
<p><strong>Notación infijo</strong></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ot">square ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>square x <span class="ot">=</span> x<span class="op">^</span><span class="dv">2</span></span></code></pre></div>
<p>Nótese que <code>^</code> usa notación infijo. Para cada operador infijo hay una notación prefijo asociada. Solo debe ponerse entre paréntesis.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>square' x <span class="ot">=</span> (<span class="op">^</span>) x <span class="dv">2</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>square'' x <span class="ot">=</span> (<span class="op">^</span><span class="dv">2</span>) x</span></code></pre></div>
<p>Podemos remover <code>x</code> en el lado izquierdo y derecho! Eso se llama reducción η.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>square''' <span class="ot">=</span> (<span class="op">^</span><span class="dv">2</span>)</span></code></pre></div>
<p>Nótese que podemos declarar funciones con un <code>'</code> en su nombre:</p>
<pre><code>square ⇔ square' ⇔ square'' ⇔ square'''</code></pre>
<p><strong>Tests</strong></p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ot">absolute ::</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>absolute x <span class="ot">=</span> <span class="kw">if</span> x <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">then</span> x <span class="kw">else</span> <span class="op">-</span>x</span></code></pre></div>
<p>Nota: el <code>if .. then .. else</code> en Haskell es como el <code>algo ? algo : algo</code> en C. No puedes olvidar el <code>else</code></p>
<p>Otra versión equivalente:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>absolute' x</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> x <span class="op">&gt;=</span> <span class="dv">0</span> <span class="ot">=</span> x</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="op">-</span>x</span></code></pre></div>
<pre><code>Advertencia: la indentación es importante en Haskell. Como en
Python, una mala indentación pueden dañar el código!</code></pre>
<h1 id="parte-difícil">Parte difícil</h1>
<p>La parte difícil puede empezar ahora.</p>
<h2 id="estilo-funcional">Estilo funcional</h2>
<p><img src="../../img/haskellhard/shot5.jpg" /></p>
<p>En esta sección, proporcionaré un ejemplo corto de la impresionante habilidad para refactorizar de Haskell. Seleccionaremos un problema y los resolveremos en la forma imperativa estándar. Luego desarrollaremos el código. Al final el resultado será más elegante y más sencillo de adaptar.</p>
<p>Solucionemos el siguiente problema:</p>
<pre><code>Dada una lista de enteros, retornar la suma de numeros pares en la lita.
ejemplo: `[1,2,3,4,5] ⇒ 2 + 4 ⇒ 6`</code></pre>
<p>Para mostrar las diferencias entre los enfoques funcional e imperativo, Empezaré con la solución imperativa (en JavaScript):</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">evenSum</span>(list) {</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> result <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="kw">var</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span> list<span class="op">.</span><span class="at">length</span> <span class="op">;</span> i<span class="op">++</span>) {</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (list[i] <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span><span class="dv">0</span>) {</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>            result <span class="op">+=</span> list[i]<span class="op">;</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>En Haskell, en contraste, no tenemos variables ni un loop <code>for</code>. Una solución para lograr el mismo resultado sin loops es usando recursión.</p>
<pre><code>Nota: La recursión es generalmente persivida como lenta en los lengajes
imperativos. Pero generalmente no es el caso en la programación funcional.
La mayor parte del tiempo Haskell manejará funciones recursivas de forma
eficiente.</code></pre>
<p>Aquí esta la versión en <code>C</code> de la función recursiva. Por simplicidad asumí que la lista de <code>int</code> termina con el primer valor de <code>0</code>.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> evenSum<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> accumSum<span class="op">(</span><span class="dv">0</span><span class="op">,</span>list<span class="op">);</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> accumSum<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>xs<span class="op">;</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(*</span>list <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span> <span class="co">// si la lista está vacia</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> list<span class="op">[</span><span class="dv">0</span><span class="op">];</span> <span class="co">// x es el primer elemento de la lista</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>        xs <span class="op">=</span> list<span class="op">+</span><span class="dv">1</span><span class="op">;</span> <span class="co">// xs es la lista sin el elemento x</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span> <span class="dv">0</span> <span class="op">==</span> <span class="op">(</span>x<span class="op">%</span><span class="dv">2</span><span class="op">)</span> <span class="op">)</span> <span class="op">{</span> <span class="co">// si x es par</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> accumSum<span class="op">(</span>n<span class="op">+</span>x<span class="op">,</span> xs<span class="op">);</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> accumSum<span class="op">(</span>n<span class="op">,</span> xs<span class="op">);</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Mantén este código en mente. Lo vamos a traducir a Haskell. Sin embargo, vamos a necesitar primero introducir tres simples pero útiles funciones que usaremos:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="fu">even</span><span class="ot"> ::</span> <span class="dt">Integrall</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</span></code></pre></div>
<p><code>even</code> verifica si un numero es par.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="fu">even</span><span class="ot"> ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="fu">even</span> <span class="dv">3</span>  ⇒ <span class="dt">False</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="fu">even</span> <span class="dv">2</span>  ⇒ <span class="dt">True</span></span></code></pre></div>
<p><code>head</code> retorna el primer elemento de la lista:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] ⇒ <span class="dv">1</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span> []      ⇒ <span class="dt">ERROR</span></span></code></pre></div>
<p><code>tail</code> retorna todos los elementos de la lista, excepto el primero:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] ⇒ [<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span> [<span class="dv">3</span>]     ⇒ []</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span> []      ⇒ <span class="dt">ERROR</span></span></code></pre></div>
<p>Nótese que para cualquier lista no vacía <code>l</code>, <code>l ⇔ (head l):(tail l)</code></p>
<p>La primera solución en Haskell. La función <code>evenSum</code> retorna la suma de todos los números pares en la lista:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Version 1</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="ot">evenSum ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>evenSum l <span class="ot">=</span> accumSum <span class="dv">0</span> l</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>accumSum n l <span class="ot">=</span> <span class="kw">if</span> l <span class="op">==</span> []</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">then</span> n</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">else</span> <span class="kw">let</span> x <span class="ot">=</span> <span class="fu">head</span> l</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>                           xs <span class="ot">=</span> <span class="fu">tail</span> l</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>                       <span class="kw">in</span> <span class="kw">if</span> <span class="fu">even</span> x</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>                              <span class="kw">then</span> accumSum (n<span class="op">+</span>x) xs</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>                              <span class="kw">else</span> accumSum n xs</span></code></pre></div>
<p>Para probar la función puedes usar <code>ghci</code>:</p>
<pre><code>% ghci
GHCi, version 7.0.3: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Prelude&gt; :load 11_Functions.lhs
[1 of 1] Compiling Main             ( 11_Functions.lhs, interpreted )
Ok, modules loaded: Main.
*Main&gt; evenSum [1..5]
6</code></pre>
<p>Aquí un ejemplo de la ejecución[^2]:</p>
<pre><code>*Main&gt; evenSum [1..5]
accumSum 0 [1,2,3,4,5]
1 is odd
accumSum 0 [2,3,4,5]
2 is even
accumSum (0+2) [3,4,5]
3 is odd
accumSum (0+2) [4,5]
2 is even
accumSum (0+2+4) [5]
5 is odd
accumSum (0+2+4) []
l == []
0+2+4
0+6
6</code></pre>
<p>Viniendo de un lenguaje imperativo todo debería parecer correcto. De hecho, muchas cosas se pueden mejorar. Primero, podemos generalizar el tipo.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evenSum ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>Luego, podemos usar sub-funciones usando <code>where</code> o <code>let</code>. De esta forma la función <code>accumSum</code> no llenará el espacio de nombres de nuestro modulo.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Version 2</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="ot">evenSum ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>evenSum l <span class="ot">=</span> accumSum <span class="dv">0</span> l</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> accumSum n l <span class="ot">=</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> l <span class="op">==</span> []</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>                <span class="kw">then</span> n</span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>                <span class="kw">else</span> <span class="kw">let</span> x <span class="ot">=</span> <span class="fu">head</span> l</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>                         xs <span class="ot">=</span> <span class="fu">tail</span> l</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">in</span> <span class="kw">if</span> <span class="fu">even</span> x</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>                            <span class="kw">then</span> accumSum (n<span class="op">+</span>x) xs</span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>                            <span class="kw">else</span> accumSum n xs</span></code></pre></div>
<p>Luego podemos usar pattern matching.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Version 3</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>evenSum l <span class="ot">=</span> accumSum <span class="dv">0</span> l</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>        accumSum n [] <span class="ot">=</span> n</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>        accumSum n (x<span class="op">:</span>xs) <span class="ot">=</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> <span class="fu">even</span> x</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>                <span class="kw">then</span> accumSum (n<span class="op">+</span>x) xs</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>                <span class="kw">else</span> accumSum n xs</span></code></pre></div>
<p>Qué es pattern matching? Usar valores en lugar de nombres de parámetro generales[^3].</p>
<p>En lugar de decir: <code>foo l = if l == [] then &lt;x&gt; else &lt;y&gt;</code> simplemente se declara:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>foo [] <span class="ot">=</span>  <span class="op">&lt;</span>x<span class="op">&gt;</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>foo l  <span class="ot">=</span>  <span class="op">&lt;</span>y<span class="op">&gt;</span></span></code></pre></div>
<p>Pero el pattern matching va más lejos. También es capaz de inspeccionar el elemento interno de un valor complejo. Podemos reemplazar</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>foo l <span class="ot">=</span>  <span class="kw">let</span> x  <span class="ot">=</span> <span class="fu">head</span> l</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>             xs <span class="ot">=</span> <span class="fu">tail</span> l</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>         <span class="kw">in</span> <span class="kw">if</span> <span class="fu">even</span> x</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>             <span class="kw">then</span> foo (n<span class="op">+</span>x) xs</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>             <span class="kw">else</span> foo n xs</span></code></pre></div>
<p>Con</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>foo (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="kw">if</span> <span class="fu">even</span> x</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">then</span> foo (n<span class="op">+</span>x) xs</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">else</span> foo n xs</span></code></pre></div>
<p>Esto es una característica muy útil. Hace nuestro código más conciso y fácil de leer.</p>
<p>En Haskell se puede simplificar las definiciones de las funciones usando reducción η. Por ejemplo, en lugar de escribir:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> (una expresion) x</span></code></pre></div>
<p>Se puede escribir</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> una expression</span></code></pre></div>
<p>Usamos este método para remover el <code>l</code>:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Version 4</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="ot">evenSum ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>evenSum <span class="ot">=</span> accumSum <span class="dv">0</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>        accumSum n [] <span class="ot">=</span> n</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>        accumSum n (x<span class="op">:</span>xs) <span class="ot">=</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> <span class="fu">even</span> x</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>                <span class="kw">then</span> accumSum (n<span class="op">+</span>x) xs</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>                <span class="kw">else</span> accumSum n xs</span></code></pre></div>
<h3 id="funciones-de-orden-superior">Funciones de orden superior</h3>
<p><img src="../../img/haskellhard/shot6.jpg" /></p>
<p>Para mejorarlo aún más podemos usar funciones de orden superior. Qué son esas bestias? Las funciones de orden superior son funciones que toman funciones como parámetros.</p>
<p>Aquí algunos ejemplos:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>Procedamos con pequeños pasos.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Version 5</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>evenSum l <span class="ot">=</span> mysum <span class="dv">0</span> (<span class="fu">filter</span> <span class="fu">even</span> l)</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>      mysum n [] <span class="ot">=</span> n</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>      mysum n (x<span class="op">:</span>xs) <span class="ot">=</span> mysum (n<span class="op">+</span>x) xs</span></code></pre></div>
<p>Donde</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span> <span class="fu">even</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>] ⇔  [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>]</span></code></pre></div>
<p>La función <code>filter</code> toma una función de tipo (<code>a -&gt; Bool</code>) y una lista de tipo <code>[a]</code>. Retorna una lista que contiene solamente los elementos para los cuales la función retornó <code>true</code>.</p>
<p>El siguiente paso es usar otra técnica para lograr el mismo resultado que un loop. Usaremos la función <code>foldl</code> para acumular los valores mientras recorremos la lista. La función <code>foldl</code> captura un patrón común:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>myfunc list <span class="ot">=</span> foo initialValue list</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>foo accumulated []     <span class="ot">=</span> accumulated</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>foo tmpValue    (x<span class="op">:</span>xs) <span class="ot">=</span> foo (bar tmpValue x) xs</span></code></pre></div>
<p>Que se puede reemplazar con:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>myfunc list <span class="ot">=</span> <span class="fu">foldl</span> bar initialValue list</span></code></pre></div>
<p>Si realmente quieres saber como funciona la magia, aquí está la definición de <code>foldl</code>:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> f z [] <span class="ot">=</span> z</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> f z (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">foldl</span> f (f z x) xs</span></code></pre></div>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> f z [x1,<span class="op">...</span>xn]</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>⇔  f (<span class="op">...</span> (f (f z x1) x2) <span class="op">...</span>) xn</span></code></pre></div>
<p>Pero como Haskell es <em>perezoso</em>, no evalúa <code>(f z x)</code> y simplemente lo empuja en la pila. Por eso generalmente usamos <code>foldl'</code> en lugar de <code>foldl</code>; <code>foldl'</code> es una versión estricta de <code>foldl</code>. Si no comprendes que significa <em>perezoso</em> o <em>estricto</em>, no te preocupes, solo sigue el código como si <code>fold</code> y <code>foldl'</code> fueran idénticos.</p>
<p>Ahora la nueva versión de <code>evenSum</code> será:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Version 6</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- foldl' isn't accessible by default</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- we need to import it from the module Data.List</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>evenSum l <span class="ot">=</span> foldl' mysum <span class="dv">0</span> (<span class="fu">filter</span> <span class="fu">even</span> l)</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> mysum acc value <span class="ot">=</span> acc <span class="op">+</span> value</span></code></pre></div>
<p>También podemos simplificar eso usando notación lambda. Así no tendremos que crear un nombre temporal <code>mysum</code>.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Version 7</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Generally it is considered a good practice</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- to import only the necessary function(s)</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (foldl')</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>evenSum l <span class="ot">=</span> foldl' (\x y <span class="ot">-&gt;</span> x<span class="op">+</span>y) <span class="dv">0</span> (<span class="fu">filter</span> <span class="fu">even</span> l)</span></code></pre></div>
<p>Y por supuesto, notamos que</p>
<p><code>(\x y -&gt; x+y) ⇔ (+)</code></p>
<p>Finalmente</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Version 8</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (foldl')</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="ot">evenSum ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>evenSum l <span class="ot">=</span> foldl' (<span class="op">+</span>) <span class="dv">0</span> (<span class="fu">filter</span> <span class="fu">even</span> l)</span></code></pre></div>
<p><code>foldl'</code> no es la función más sencilla de comprender. Si no estas acostumbrado, deberías estudiarlo un poco.</p>
<p>Para ayudar a comprender que está sucediendo aquí, miremos la evaluación paso por paso:</p>
<pre><code>evenSum [1,2,3,4]
⇒ foldl' (+) 0 (filter even [1,2,3,4])
⇒ foldl' (+) 0 [2,4]
⇒ foldl' (+) (0+2) [4]
⇒ foldl' (+) 2 [4]
⇒ foldl' (+) (2+4) []
⇒ foldl' (+) 6 []
⇒ 6</code></pre>
<p>Otra función de orden superior útil es <code>(.)</code>. La función <code>(.)</code> corresponde a la composición matemática de funciones.</p>
<p><code>(f . g . h) x ⇔  f ( g (h x))</code></p>
<p>Podemos tomar ventaja de este operador para hacer una reducción η en nuestra función:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Version 9</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (foldl')</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="ot">evenSum ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>evenSum <span class="ot">=</span> (foldl' (<span class="op">+</span>) <span class="dv">0</span>) <span class="op">.</span> (<span class="fu">filter</span> <span class="fu">even</span>)</span></code></pre></div>
<p>También, podemos renombrar algunas partes para hacerlo más claro:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Version 10</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (foldl')</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a><span class="ot">sum' ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>sum' <span class="ot">=</span> foldl' (<span class="op">+</span>) <span class="dv">0</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a><span class="ot">evenSum ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>evenSum <span class="ot">=</span> sum' <span class="op">.</span> (<span class="fu">filter</span> <span class="fu">even</span>)</span></code></pre></div>
<p>Es tiempo de hablar sobre la dirección hacia la cual se ha movido nuestro código mientras introducimos más de la forma funcional. Qué hemos ganado al usar funciones de orden superior?</p>
<p>Al principio podrías pensar que la principal diferencia es la brevedad. Pero en realidad tiene más que ver con la forma en la que se piensa. Supongamos que se quiere modificar un poco la función, por ejemplo, para obtener la suma de los cuadrados de los elementos pares de la lista.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>] ▷ [<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">9</span>,<span class="dv">16</span>] ▷ [<span class="dv">4</span>,<span class="dv">16</span>] ▷ <span class="dv">20</span></span></code></pre></div>
<p>Actualizar la versión 10 es muy fácil:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>squareEvenSum <span class="ot">=</span> sum' <span class="op">.</span> (<span class="fu">filter</span> <span class="fu">even</span>) <span class="op">.</span> (<span class="fu">map</span> (<span class="op">^</span><span class="dv">2</span>))</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>squareEvenSum' <span class="ot">=</span> evenSum <span class="op">.</span> (<span class="fu">map</span> (<span class="op">^</span><span class="dv">2</span>))</span></code></pre></div>
<p>Solamente agregamos otra “función de transformación”.</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> (<span class="op">^</span><span class="dv">2</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>] ⇔ [<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">9</span>,<span class="dv">16</span>]</span></code></pre></div>
<p>La función <code>map</code> simplemente aplica una función sobre todos los elementos de una lista.</p>
<p>No tuvimos que modificar nada <em>dentro</em> de la definición de la función. Esto hace el código más modular. Pero también permite pensar en la función de forma más matemática. También se puede usar la función intercambiablemente con otras, según se necesite. Esto es, se puede hacer compose, map, fold, filter usando la nueva función.</p>
<p>Modificar la versión 1 se deja como ejercicio para el lector ☺.</p>
<p>Si piensas que hemos llegado al final de la generalización, entonces enterate que estas muy equivocado. Por ejemplo, hay una forma de usar esta fucnion no solo en listas, sino ademas sobre cualquier tipo recursivo. Si quieres saber como, recomiendo que leas este <a href="http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf">artículo</a></p>
<p>Este ejemplo debería demostrar cuan genial es la programación funcional. Desafortunadamente, usar programación funcional pura no es adecuado para todos los usos. O al menos un lenguaje que lo permite no se a logrado aún.</p>
<p>Uno de los mayores poderes de Haskell es la habilidad de crear DSLs (Lenguaje de dominio específico) haciendo sencillo cambiar el paradigma de programación.</p>
<p>De hecho, Haskell también es grandioso cuando se quiere escribir en estilo imperativo. Comprender esto fue muy difícil para mi cuando aprendía Haskell. Gran parte del esfuerzo se va intentando explicar la superioridad del enfoque funcional. Luego cuando empiezas a usar estilo imperativo con Haskell, puede ser difícil entender dónde y cómo usarlo.</p>
<p>Pero antes de hablar sobre este super poder de Haskell, debemos hablar sobre otro aspecto esencial de Haskell: Tipos.</p>
<h2 id="tipos">Tipos</h2>
<p><img src="../../img/haskellhard/shot7.jpg" /></p>
<p>TL;DR*:</p>
<ul>
<li><p><code>type Nombre = OtroTipo</code> es solamente un alias y no hay ninguna diferencia entre <code>Nombre</code> y <code>OtroTipo</code>.</p></li>
<li><p><code>data Nombre = NombreConstructor OtroTipo</code> tiene diferencia</p></li>
<li><p><code>data</code> puede construir estructuras que pueden ser recursivas</p></li>
<li><p><code>deriving</code> es mágico y crea funciones por ti</p></li>
</ul>
<p>En Haskell, los tipos son fuertes y estáticos.</p>
<p>Por qué es importante? Permitirá en <em>gran</em> medida evitar errores. En Haskell, la mayoría de los errores se capturan durante la compilación del programa. Y la razón principal es debido a la inferencia de tipos durante la compilación. La inferencia de tipos hace sencillo detectar donde se usó el parámetro incorrecto en el lugar incorrecto, por ejemplo.</p>
<h3 id="inferencia-de-tipos">Inferencia de tipos</h3>
<p>El tipado estático es generalmente esencial para la ejecución veloz. Pero la mayoría de lenguajes estáticamente tipado son malos generalizando conceptos. La ventaja de Haskell es su capacidad para inferir tipos.</p>
<p>Aquí un ejemplo simple, la función <code>square</code> en Haskell:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>square x <span class="ot">=</span> x <span class="op">*</span> x</span></code></pre></div>
<p>Esta función puede elevar al cuadrado cualquier tipo Numérico. Se puede pasar a <code>square</code> un <code>Int</code>, un <code>Integer</code>, un <code>Float</code>, un <code>Fractional</code> e incluso un <code>Complex</code>. Por ejemplo:</p>
<pre><code>% ghci
GHCi, version 7.0.4:
...
Prelude&gt; let square x = x*x
Prelude&gt; square 2
4
Prelude&gt; square 2.1
4.41
Prelude&gt; -- load the Data.Complex module
Prelude&gt; :m Data.Complex
Prelude Data.Complex&gt; square (2 :+ 1)
3.0 :+ 4.0</code></pre>
<p><code>x :+ y</code> es la notación para el complejo (x + iy).</p>
<p>Ahora compáralo con la cantidad de código necesario en <code>C</code>:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span>     int_square<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">*</span>x<span class="op">;</span> <span class="op">}</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span>   float_square<span class="op">(</span><span class="dt">float</span> x<span class="op">)</span> <span class="op">{</span><span class="cf">return</span> x<span class="op">*</span>x<span class="op">;</span> <span class="op">}</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="dt">complex</span> complex_square <span class="op">(</span><span class="dt">complex</span> z<span class="op">)</span> <span class="op">{</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">complex</span> tmp<span class="op">;</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>    tmp<span class="op">.</span>real <span class="op">=</span> z<span class="op">.</span>real <span class="op">*</span> z<span class="op">.</span>real <span class="op">-</span> z<span class="op">.</span>img <span class="op">*</span> z<span class="op">.</span>img<span class="op">;</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>    tmp<span class="op">.</span>img <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> z<span class="op">.</span>img <span class="op">*</span> z<span class="op">.</span>real<span class="op">;</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a><span class="dt">complex</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> complex_square<span class="op">(</span>x<span class="op">);</span></span></code></pre></div>
<p>Para cada tipo, se necesita escribir una nueva función. La única forma de solucionar esto es usando algún truco de meta-programación, por ejemplo usando el pre-procesador. En C++ hay una mejor forma usando templates:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;complex&gt;</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>T square<span class="op">(</span>T x<span class="op">)</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">*</span>x<span class="op">;</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// int</span></span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sqr_of_five <span class="op">=</span> square<span class="op">(</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> sqr_of_five <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// double</span></span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="op">(</span><span class="dt">double</span><span class="op">)</span>square<span class="op">(</span><span class="fl">5.3</span><span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// complex</span></span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> square<span class="op">(</span> complex<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span><span class="dv">5</span><span class="op">,</span><span class="dv">3</span><span class="op">)</span> <span class="op">)</span></span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>C++ lo hace mucho mejor que C en este aspecto. Pero para funciones más complejas la sintaxis puede ser difícil de entender: Mira <a href="http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/">este artículo</a> por ejemplo.</p>
<p>En C++ se debe declarar que la función puede trabajar con distintos tipos. En Haskell, es lo opuesto. La función será lo más general posible por defecto.</p>
<p>La inferencia de tipos le da a Haskell la sensación de libertad de los lenguajes de tipado dinámico. Pero a diferencia de estos, la mayoría de los errores se encuentra antes de la ejecución. Generalmente, en Haskell:</p>
<blockquote>
<p>“Si compila entonces hace lo que quieres que haga”</p>
</blockquote>
<h3 id="construcción-de-tipos">Construcción de tipos</h3>
<p>Es posible construir tipos propios. Primero, se pueden usar alias o sinónimos de tipos.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Name</span>   <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Color</span>  <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="ot">showInfos ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span>  <span class="dt">Color</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>showInfos name color <span class="ot">=</span>  <span class="st">&quot;Name: &quot;</span> <span class="op">++</span> name</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>                        <span class="op">++</span> <span class="st">&quot;, Color: &quot;</span> <span class="op">++</span> color</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a><span class="ot">name ::</span> <span class="dt">Name</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>name <span class="ot">=</span> <span class="st">&quot;Robin&quot;</span></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a><span class="ot">color ::</span> <span class="dt">Color</span></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a>color <span class="ot">=</span> <span class="st">&quot;Blue&quot;</span></span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">$</span> showInfos name color</span></code></pre></div>
<p>Pero esto no te protege mucho. Intenta intercambiar los dos parámetros de <code>showInfos</code> y ejecuta el programa:</p>
<pre><code>putStrLn $ showInfos color name</code></pre>
<p>Se compilará y ejecutará. De hecho se pueden reemplazar <code>Name</code>, <code>Color</code> y <code>String</code> con cualquier cosa. El compilador los tratará como si fueran idénticos.</p>
<p>Otro método es crear tus propios tipos usando la palabra reservada <code>data</code>.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Name</span>   <span class="ot">=</span> <span class="dt">NameConstr</span> <span class="dt">String</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Color</span>  <span class="ot">=</span> <span class="dt">ColorConstr</span> <span class="dt">String</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a><span class="ot">showInfos ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span>  <span class="dt">Color</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>showInfos (<span class="dt">NameConstr</span> name) (<span class="dt">ColorConstr</span> color) <span class="ot">=</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;Name: &quot;</span> <span class="op">++</span> name <span class="op">++</span> <span class="st">&quot;, Color: &quot;</span> <span class="op">++</span> color</span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>name  <span class="ot">=</span> <span class="dt">NameConstr</span> <span class="st">&quot;Robin&quot;</span></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>color <span class="ot">=</span> <span class="dt">ColorConstr</span> <span class="st">&quot;Blue&quot;</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">$</span> showInfos name color</span></code></pre></div>
<p>Ahora si intercambias los parámetros de <code>showInfos</code>, el compilador se queja! De forma que nunca más podrás cometer un error de ese tipo y el único precio es ser un poco más explicito.</p>
<p>También nota que los constructores son funciones:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="dt">NameConstr</span><span class="ot">  ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Name</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="dt">ColorConstr</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Color</span></span></code></pre></div>
<p>La sintaxis de <code>data</code> es principalmente:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TypeName</span> <span class="ot">=</span>   <span class="dt">ConstructorName</span>  [types]</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>                <span class="op">|</span> <span class="dt">ConstructorName2</span> [types]</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>                <span class="op">|</span> <span class="op">...</span></span></code></pre></div>
<p>Generalmente se usa el mismo nombre para el <code>DataTypeName</code> y para el <code>DataTypeConstructor</code>.</p>
<p>Ejemplo:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Complex</span> a <span class="ot">=</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Complex</span> a a</span></code></pre></div>
<p>También se puede usar sintaxis record:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DataTypeName</span> <span class="ot">=</span> <span class="dt">DataConstructor</span> {</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="ot">                      field1 ::</span> [<span class="kw">type</span> <span class="kw">of</span> field1]</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>                    ,<span class="ot"> field2 ::</span> [<span class="kw">type</span> <span class="kw">of</span> field2]</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>                    <span class="op">...</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>                    ,<span class="ot"> fieldn ::</span> [<span class="kw">type</span> <span class="kw">of</span> fieldn] }</span></code></pre></div>
<p>Y hay varios accesores disponibles. Además se puede usar otro orden cuando se asignen valores.</p>
<p>Ejemplo:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Complex</span> a <span class="ot">=</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Complex</span> {<span class="ot"> real ::</span> a,<span class="ot"> img ::</span> a}</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>c <span class="ot">=</span> <span class="dt">Complex</span> <span class="fl">1.0</span> <span class="fl">2.0</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>z <span class="ot">=</span> <span class="dt">Complex</span> { real <span class="ot">=</span> <span class="dv">3</span>, img <span class="ot">=</span> <span class="dv">4</span> }</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>real c ⇒ <span class="fl">1.0</span></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>img z ⇒ <span class="dv">4</span></span></code></pre></div>
<h3 id="tipos-recursivos">Tipos recursivos</h3>
<p>Ya nos hemos topado con un tipo recursivo: listas. Se pueden re-crear listas, pero con una sintaxis más explicita:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Empty</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span></code></pre></div>
<p>Si prefieres usar una sintaxis más simple, se puede usar un nombre infijo para los constructores.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:::</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> a <span class="op">:::</span> (<span class="dt">List</span> a)</span></code></pre></div>
<p>El numero luego de <code>infixr</code> le da la precedencia.</p>
<p>Si quieres poder imprimir por pantalla (<code>Show</code>), leer (<code>Read</code>), probar igualdad (<code>Eq</code>) y comparar (<code>Ord</code>) con tu nueva estructura de datos puedes pedirle a Haskell que derive las funciones apropiadas por ti.</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:::</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> a <span class="op">:::</span> (<span class="dt">List</span> a)</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>              <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Read</span>,<span class="dt">Eq</span>,<span class="dt">Ord</span>)</span></code></pre></div>
<p>Cuando añades <code>deriving (Show)</code> a tu declaración de datos, Haskell crea una función <code>show</code> por ti. Ya veremos como se puede usar una función <code>show</code> propia.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>convertList [] <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>convertList (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">:::</span> convertList xs</span></code></pre></div>
<div class="sourceCode" id="cb95"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span> (<span class="dv">0</span> <span class="op">:::</span> <span class="dv">1</span> <span class="op">:::</span> <span class="dt">Nil</span>)</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span> (convertList [<span class="dv">0</span>,<span class="dv">1</span>])</span></code></pre></div>
<p>Esto imprime:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">:::</span> (<span class="dv">1</span> <span class="op">:::</span> <span class="dt">Nil</span>)</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">:::</span> (<span class="dv">1</span> <span class="op">:::</span> <span class="dt">Nil</span>)</span></code></pre></div>
<h3 id="arboles">Arboles</h3>
<p><img src="../../img/haskellhard/shot8.jpg" /></p>
<p>Otro ejemplo estándar: arboles binarios.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">BinTree</span> a <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>                 <span class="op">|</span> <span class="dt">Node</span> a (<span class="dt">BinTree</span> a) (<span class="dt">BinTree</span> a)</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>                              <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
<p>También crearemos una función que convierta una lista en un árbol binario ordenado.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="ot">treeFromList ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>treeFromList [] <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>treeFromList (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Node</span> x (treeFromList (<span class="fu">filter</span> (<span class="op">&lt;</span>x) xs))</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>                             (treeFromList (<span class="fu">filter</span> (<span class="op">&gt;</span>x) xs))</span></code></pre></div>
<p>Observa cuan elegante es esta función.</p>
<ul>
<li>Una lista vacía será convertida en un árbol vació.</li>
<li>Una lista <code>(x:xs)</code> será convertida en un árbol donde: ** La raíz es <code>x</code> ** El sub-árbol de la izquierda es el árbol creado de los miembros de la lista ** <code>xs</code> que son menores a <code>x</code> y ** El sub-árbol de la derecha es el árbol creado de los miembros de la lista <code>xs</code> ** que son mayores que <code>x</code>.</li>
</ul>
<div class="sourceCode" id="cb99"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> treeFromList [<span class="dv">7</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">8</span>]</span></code></pre></div>
<p>Deberías obtener lo siguiente:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Node</span> <span class="dv">7</span> (<span class="dt">Node</span> <span class="dv">2</span> <span class="dt">Empty</span> (<span class="dt">Node</span> <span class="dv">4</span> <span class="dt">Empty</span> <span class="dt">Empty</span>)) (<span class="dt">Node</span> <span class="dv">8</span> <span class="dt">Empty</span> <span class="dt">Empty</span>)</span></code></pre></div>
<p>Esta es una forma informativa pero no muy agradable de nuestro árbol.</p>
<p>Solo por diversión, hagamos que nuestros arboles se visualicen de una mejor forma. Simplemente resulta divertido hacer una función para mostrar arboles en una forma general. Puedes saltarte esta parta si te parece muy difícil.</p>
<p>Tenemos unos cuantos cambios que hacer. Remover el <code>deriving (Show)</code> de la declaración del tipo <code>BinTree</code>. Y también sería útil hacer nuestras propias infancias de (<code>Eq</code> y <code>Ord</code>) de forma que podamos probar igualdad y comprar arboles.</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">BinTree</span> a <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>                 <span class="op">|</span> <span class="dt">Node</span> a (<span class="dt">BinTree</span> a) (<span class="dt">BinTree</span> a)</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Ord</span>)</span></code></pre></div>
<p>Sin el <code>deriving (Show)</code>, Haskell no creará una función <code>show</code> por nosotros. Crearemos nuestra propia versión de <code>show</code>. Para lograrlo, debemos declarar que nuestro nuevo tipo <code>BinTree a</code> es una instancia de la clase de tipo <code>Show</code>. La sintaxis general es:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">BinTree</span> a) <span class="kw">where</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>   <span class="fu">show</span> t <span class="ot">=</span> <span class="op">...</span> <span class="co">-- You declare your function here</span></span></code></pre></div>
<p>Aquí está mi versión de como mostrar un árbol binario. No te preocupes de la aparente complejidad. Hice un montón de mejoras para mostrar incluso objetos extraños.</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- declare BinTree a to be an instance of Show</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">BinTree</span> a) <span class="kw">where</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- will start by a '&lt;' before the root</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- and put a : a begining of line</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> t <span class="ot">=</span> <span class="st">&quot;&lt; &quot;</span> <span class="op">++</span> replace <span class="ch">'\n'</span> <span class="st">&quot;\n: &quot;</span> (treeshow <span class="st">&quot;&quot;</span> t)</span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- treeshow pref Tree</span></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">--   shows a tree and starts each line with pref</span></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- We don't display the Empty tree</span></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a>    treeshow pref <span class="dt">Empty</span> <span class="ot">=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Leaf</span></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a>    treeshow pref (<span class="dt">Node</span> x <span class="dt">Empty</span> <span class="dt">Empty</span>) <span class="ot">=</span></span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>                  (pshow pref x)</span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-15"><a href="#cb103-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Right branch is empty</span></span>
<span id="cb103-16"><a href="#cb103-16" aria-hidden="true" tabindex="-1"></a>    treeshow pref (<span class="dt">Node</span> x left <span class="dt">Empty</span>) <span class="ot">=</span></span>
<span id="cb103-17"><a href="#cb103-17" aria-hidden="true" tabindex="-1"></a>                  (pshow pref x) <span class="op">++</span> <span class="st">&quot;\n&quot;</span> <span class="op">++</span></span>
<span id="cb103-18"><a href="#cb103-18" aria-hidden="true" tabindex="-1"></a>                  (showSon pref <span class="st">&quot;`--&quot;</span> <span class="st">&quot;   &quot;</span> left)</span>
<span id="cb103-19"><a href="#cb103-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-20"><a href="#cb103-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Left branch is empty</span></span>
<span id="cb103-21"><a href="#cb103-21" aria-hidden="true" tabindex="-1"></a>    treeshow pref (<span class="dt">Node</span> x <span class="dt">Empty</span> right) <span class="ot">=</span></span>
<span id="cb103-22"><a href="#cb103-22" aria-hidden="true" tabindex="-1"></a>                  (pshow pref x) <span class="op">++</span> <span class="st">&quot;\n&quot;</span> <span class="op">++</span></span>
<span id="cb103-23"><a href="#cb103-23" aria-hidden="true" tabindex="-1"></a>                  (showSon pref <span class="st">&quot;`--&quot;</span> <span class="st">&quot;   &quot;</span> right)</span>
<span id="cb103-24"><a href="#cb103-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-25"><a href="#cb103-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Tree with left and right children non empty</span></span>
<span id="cb103-26"><a href="#cb103-26" aria-hidden="true" tabindex="-1"></a>    treeshow pref (<span class="dt">Node</span> x left right) <span class="ot">=</span></span>
<span id="cb103-27"><a href="#cb103-27" aria-hidden="true" tabindex="-1"></a>                  (pshow pref x) <span class="op">++</span> <span class="st">&quot;\n&quot;</span> <span class="op">++</span></span>
<span id="cb103-28"><a href="#cb103-28" aria-hidden="true" tabindex="-1"></a>                  (showSon pref <span class="st">&quot;|--&quot;</span> <span class="st">&quot;|  &quot;</span> left) <span class="op">++</span> <span class="st">&quot;\n&quot;</span> <span class="op">++</span></span>
<span id="cb103-29"><a href="#cb103-29" aria-hidden="true" tabindex="-1"></a>                  (showSon pref <span class="st">&quot;`--&quot;</span> <span class="st">&quot;   &quot;</span> right)</span>
<span id="cb103-30"><a href="#cb103-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-31"><a href="#cb103-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- shows a tree using some prefixes to make it nice</span></span>
<span id="cb103-32"><a href="#cb103-32" aria-hidden="true" tabindex="-1"></a>    showSon pref before next t <span class="ot">=</span></span>
<span id="cb103-33"><a href="#cb103-33" aria-hidden="true" tabindex="-1"></a>                  pref <span class="op">++</span> before <span class="op">++</span> treeshow (pref <span class="op">++</span> next) t</span>
<span id="cb103-34"><a href="#cb103-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-35"><a href="#cb103-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- pshow replaces &quot;\n&quot; by &quot;\n&quot;++pref</span></span>
<span id="cb103-36"><a href="#cb103-36" aria-hidden="true" tabindex="-1"></a>    pshow pref x <span class="ot">=</span> replace <span class="ch">'\n'</span> (<span class="st">&quot;\n&quot;</span><span class="op">++</span>pref) (<span class="fu">show</span> x)</span>
<span id="cb103-37"><a href="#cb103-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-38"><a href="#cb103-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- replaces one char by another string</span></span>
<span id="cb103-39"><a href="#cb103-39" aria-hidden="true" tabindex="-1"></a>    replace c new string <span class="ot">=</span></span>
<span id="cb103-40"><a href="#cb103-40" aria-hidden="true" tabindex="-1"></a>      <span class="fu">concatMap</span> (change c new) string</span>
<span id="cb103-41"><a href="#cb103-41" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb103-42"><a href="#cb103-42" aria-hidden="true" tabindex="-1"></a>          change c new x</span>
<span id="cb103-43"><a href="#cb103-43" aria-hidden="true" tabindex="-1"></a>              <span class="op">|</span> x <span class="op">==</span> c <span class="ot">=</span> new</span>
<span id="cb103-44"><a href="#cb103-44" aria-hidden="true" tabindex="-1"></a>              <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> x<span class="op">:</span>[] <span class="co">-- &quot;x&quot;</span></span></code></pre></div>
<p>El método <code>treeFromList</code> permanece idéntico.</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="ot">treeFromList ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>treeFromList [] <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>treeFromList (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Node</span> x (treeFromList (<span class="fu">filter</span> (<span class="op">&lt;</span>x) xs))</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>                             (treeFromList (<span class="fu">filter</span> (<span class="op">&gt;</span>x) xs))</span></code></pre></div>
<p>Y ahora, podemos jugar:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Int binary tree:&quot;</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> treeFromList [<span class="dv">7</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">8</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">6</span>,<span class="dv">21</span>,<span class="dv">12</span>,<span class="dv">23</span>]</span></code></pre></div>
<pre><code>Int binary tree:
&lt; 7
: |--2
: |  |--1
: |  `--4
: |     |--3
: |     `--6
: `--8
:    `--21
:       |--12
:       `--23</code></pre>
<p>Ahora es mucho mejor! La raíz se muestra iniciando la linea con <code>&lt;</code>. Y cada linea que le sigue inicia con <code>:</code>. Pero también podríamos usar otro tipo.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="fu">putStrLn</span> <span class="st">&quot;\nString binary tree:&quot;</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span> <span class="op">$</span> treeFromList [<span class="st">&quot;foo&quot;</span>,<span class="st">&quot;bar&quot;</span>,<span class="st">&quot;baz&quot;</span>,<span class="st">&quot;gor&quot;</span>,<span class="st">&quot;yog&quot;</span>]</span></code></pre></div>
<pre><code>String binary tree:
&lt; &quot;foo&quot;
: |--&quot;bar&quot;
: |  `--&quot;baz&quot;
: `--&quot;gor&quot;
:    `--&quot;yog&quot;</code></pre>
<p>Como podemos probar igualdad y ordenar arboles, podemos hacer arboles de arboles!</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="fu">putStrLn</span> <span class="st">&quot;\nBinary tree of Char binary trees:&quot;</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span> ( treeFromList</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>        (<span class="fu">map</span> treeFromList [<span class="st">&quot;baz&quot;</span>,<span class="st">&quot;zara&quot;</span>,<span class="st">&quot;bar&quot;</span>]))</span></code></pre></div>
<pre><code>Binary tree of Char binary trees:
&lt; &lt; 'b'
: : |--'a'
: : `--'z'
: |--&lt; 'b'
: |  : |--'a'
: |  : `--'r'
: `--&lt; 'z'
:    : `--'a'
:    :    `--'r'</code></pre>
<p>Por eso elegí poner un <code>:</code> en cada linea del árbol (excepto en la raíz).</p>
<p><img src="../../img/haskellhard/shot9.jpg" /></p>
<div class="sourceCode" id="cb111"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="fu">putStrLn</span> <span class="st">&quot;\nTree of Binary trees of Char binary trees:&quot;</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span> <span class="op">$</span> (treeFromList <span class="op">.</span> <span class="fu">map</span> (treeFromList <span class="op">.</span> <span class="fu">map</span> treeFromList))</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>            [ [<span class="st">&quot;YO&quot;</span>,<span class="st">&quot;DAWG&quot;</span>]</span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>            , [<span class="st">&quot;I&quot;</span>,<span class="st">&quot;HEARD&quot;</span>]</span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>            , [<span class="st">&quot;I&quot;</span>,<span class="st">&quot;HEARD&quot;</span>]</span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>            , [<span class="st">&quot;YOU&quot;</span>,<span class="st">&quot;LIKE&quot;</span>,<span class="st">&quot;TREES&quot;</span>] ]</span></code></pre></div>
<p>Que es equivalente a</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span> ( treeFromList (</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>          <span class="fu">map</span> treeFromList</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>             [ <span class="fu">map</span> treeFromList [<span class="st">&quot;YO&quot;</span>,<span class="st">&quot;DAWG&quot;</span>]</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>             , <span class="fu">map</span> treeFromList [<span class="st">&quot;I&quot;</span>,<span class="st">&quot;HEARD&quot;</span>]</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>             , <span class="fu">map</span> treeFromList [<span class="st">&quot;I&quot;</span>,<span class="st">&quot;HEARD&quot;</span>]</span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a>             , <span class="fu">map</span> treeFromList [<span class="st">&quot;YOU&quot;</span>,<span class="st">&quot;LIKE&quot;</span>,<span class="st">&quot;TREES&quot;</span>] ]))</span></code></pre></div>
<p>Y produce:</p>
<pre><code>Binary tree of Binary trees of Char binary trees:
&lt; &lt; &lt; 'Y'
: : : `--'O'
: : `--&lt; 'D'
: :    : |--'A'
: :    : `--'W'
: :    :    `--'G'
: |--&lt; &lt; 'I'
: |  : `--&lt; 'H'
: |  :    : |--'E'
: |  :    : |  `--'A'
: |  :    : |     `--'D'
: |  :    : `--'R'
: `--&lt; &lt; 'Y'
:    : : `--'O'
:    : :    `--'U'
:    : `--&lt; 'L'
:    :    : `--'I'
:    :    :    |--'E'
:    :    :    `--'K'
:    :    `--&lt; 'T'
:    :       : `--'R'
:    :       :    |--'E'
:    :       :    `--'S'</code></pre>
<p>Nota como arboles duplicados no son insertados; solo hay un árbol correspondiente a <code>"I", "HEARD"</code>. Podemos tener esto (casi) gratuitamente, por que hemos declarado que el tipo árbol es una instancia de <code>Eq</code>.</p>
<p>Mira cuan genial es esta estructura: Podemos hacer arboles que contienen no solo enteros, cadenas y caracteres, sino también arboles. Y podemos incluso hacer un árbol que contenga arboles de arboles!</p>
<h2 id="estructuras-infinitas">Estructuras infinitas</h2>
<p><img src="../../img/haskellhard/shot10.jpg" /></p>
<p>Es común escuchar que Haskell es perezoso.</p>
<p>De hecho, si se es un poco pedante, se debería decir que <a href="http://www.haskell.org/haskellwiki/Lazy_vs._non-strict">Haskell es no-estricto.</a>. Pereza es solo una implementación común de lenguajes no-estrictos.</p>
<p>¿Pero qué significa “no-estricto”? Desde la wiki de Haskell:</p>
<pre><code>Reduction (the mathematical term for evaluation) proceeds from the outside in.

so if you have (a+(b*c)) then you first reduce + first, then you reduce the inner (b*c)</code></pre>
<p>Por ejemplo en Haskell se puede hacer:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- numbers = [1,2,..]</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="ot">numbers ::</span> [<span class="dt">Integer</span>]</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>numbers <span class="ot">=</span> <span class="dv">0</span><span class="op">:</span><span class="fu">map</span> (<span class="dv">1</span><span class="op">+</span>) numbers</span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>take' n [] <span class="ot">=</span> []</span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>take' <span class="dv">0</span> l <span class="ot">=</span> []</span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>take' n (x<span class="op">:</span>xs) <span class="ot">=</span> x<span class="op">:</span>take' (n<span class="op">-</span><span class="dv">1</span>) xs</span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> take' <span class="dv">10</span> numbers</span></code></pre></div>
<p>Y se detiene.</p>
<p>¿Cómo?</p>
<p>En lugar de intentar evaluar <code>numbers</code> por completo, evalúa los elementos solo cunado se los necesita.</p>
<p>También, nótese que en Haskell hay una notación para listas infinitas.</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span><span class="op">..</span>]   ⇔ [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span><span class="op">...</span>]</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">3</span><span class="op">..</span>] ⇔ [<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span><span class="op">...</span>]</span></code></pre></div>
<p>Y la mayoría de las funciones funcionarán con ellas. También, hay una función <code>take</code> que es equivalente a nuestro <code>take'</code></p>
<p>Supón que queremos un árbol ordenado binario. Aquí hay una árbol binario infinito.</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>nullTree <span class="ot">=</span> <span class="dt">Node</span> <span class="dv">0</span> nullTree nullTree</span></code></pre></div>
<p>Un árbol binario completo donde cada nodo es iguala a 0. Ahora probaré que se puede manipular este objeto usando la siguiente función:</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- take all element of a BinTree</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- up to some depth</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>treeTakeDepth _ <span class="dt">Empty</span> <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>treeTakeDepth <span class="dv">0</span> _     <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>treeTakeDepth n (<span class="dt">Node</span> x left right) <span class="ot">=</span> <span class="kw">let</span></span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>          nl <span class="ot">=</span> treeTakeDepth (n<span class="op">-</span><span class="dv">1</span>) left</span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>          nr <span class="ot">=</span> treeTakeDepth (n<span class="op">-</span><span class="dv">1</span>) right</span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>          <span class="kw">in</span></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>              <span class="dt">Node</span> x nl nr</span></code></pre></div>
<p>Mira lo que ocurre con este programa:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> treeTakeDepth <span class="dv">4</span> nullTree</span></code></pre></div>
<p>Este código compila, se ejecuta y se detiene dando el siguiente resultado:</p>
<pre><code>&lt;  0
: |-- 0
: |  |-- 0
: |  |  |-- 0
: |  |  `-- 0
: |  `-- 0
: |     |-- 0
: |     `-- 0
: `-- 0
:    |-- 0
:    |  |-- 0
:    |  `-- 0
:    `-- 0
:       |-- 0
:       `-- 0</code></pre>
<p>Solo para calentar tus neuronas, hagamos un árbol más interesante:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>iTree <span class="ot">=</span> <span class="dt">Node</span> <span class="dv">0</span> (dec iTree) (inc iTree)</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>           dec (<span class="dt">Node</span> x l r) <span class="ot">=</span> <span class="dt">Node</span> (x<span class="op">-</span><span class="dv">1</span>) (dec l) (dec r)</span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>           inc (<span class="dt">Node</span> x l r) <span class="ot">=</span> <span class="dt">Node</span> (x<span class="op">+</span><span class="dv">1</span>) (inc l) (inc r)</span></code></pre></div>
<p>Otra forma de crear ese árbol es usar una función de orden superior. Esta función debería ser similar a <code>map</code>, pero debería funcionar en <code>BinTree</code> en lugar de una lista. Aquí está la función:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- apply a function to each node of Tree</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a><span class="ot">treeMap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> b</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>treeMap f <span class="dt">Empty</span> <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>treeMap f (<span class="dt">Node</span> x left right) <span class="ot">=</span> <span class="dt">Node</span> (f x)</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>                                     (treeMap f left)</span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a>                                     (treeMap f right)</span></code></pre></div>
<p>Nota: No hablaré más de esto aquí. Si estas interesado en la generalización de <code>map</code> a otras estructuras de datos, busca <em>functor</em> y <code>fmap</code>.</p>
<p>Nuestra definición es ahora:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="ot">infTreeTwo ::</span> <span class="dt">BinTree</span> <span class="dt">Int</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>infTreeTwo <span class="ot">=</span> <span class="dt">Node</span> <span class="dv">0</span> (treeMap (\x <span class="ot">-&gt;</span> x<span class="op">-</span><span class="dv">1</span>) infTreeTwo)</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>                    (treeMap (\x <span class="ot">-&gt;</span> x<span class="op">+</span><span class="dv">1</span>) infTreeTwo)</span></code></pre></div>
<p>Observa el resultado de</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> treeTakeDepth <span class="dv">4</span> infTreeTwo</span></code></pre></div>
<pre><code>&lt;  0
: |-- -1
: |  |-- -2
: |  |  |-- -3
: |  |  `-- -1
: |  `-- 0
: |     |-- -1
: |     `-- 1
: `-- 1
:    |-- 0
:    |  |-- -1
:    |  `-- 1
:    `-- 2
:       |-- 1
:       `-- 3</code></pre>
<h1 id="parte-infernalmente-difícil">Parte infernalmente difícil</h1>
<p>Felicitaciones por llegar tan lejos! Ahora, algunas de las cosas realmente difíciles pueden empezar.</p>
<p>Si eres como yo, ya deberías comprender el estilo funcional. También deberías entender un poco más de las ventajas de la <em>pereza</em> (Laziness) por defecto. Pero también deberías NO comprender aún como empezar a escribir un programa real. Y en particular:</p>
<ul>
<li>¿Cómo se lidia con los efectos?</li>
<li>¿Por qué hay una notación extraña parecida a la imperativa para lidiar con Entrada/Salida (IO)?</li>
</ul>
<p>Prepárate, las respuestas pueden ser complejas. Pero son realmente gratificantes.</p>
<h2 id="lidiando-con-io-entradasalida">Lidiando con IO (Entrada/Salida)</h2>
<p><img src="../../img/haskellhard/shot11.jpg" /></p>
<p><em>TL;DR</em>:</p>
<p>Una función típica haciendo IO es muy parecida a un programa imperativo:</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">IO</span> a</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> action1</span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>  action2 x</span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> action3</span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>  action4 x y</span></code></pre></div>
<ul>
<li>Para asignar un valor a un objeto se usa <code>&lt;-</code>.</li>
<li>El tipo de cada linea es <code>IO *</code>; en este ejemplo:</li>
<li><code>action1 :: IO b</code></li>
<li><code>action2 x :: IO ()</code></li>
<li><code>action3 :: IO c</code></li>
<li><code>action4 x y :: IO a</code></li>
<li><code>x :: b</code>, <code>y :: c</code></li>
<li>Algunos objetos tienen el tipo <code>IO a</code>, esto debería ayudar a elegir. En particular no se deberían usar funciones puras aquí. Para usar funciones se puede hacer <code>action2 (purefunction x)</code> por ejemplo.</li>
</ul>
<p>En esta sección,, explicaré como usar IO, no como funciona. Se verá como Haskell separa la partes puras del programa de las impuras.</p>
<p>No te detengas por que intentas comprender los detalles de la sintaxis. Las respuestas vendrán en la siguiente sección.</p>
<p>Qué queremos lograr?</p>
<pre><code>Pedir al usuario que ingrese una lista de números. Imprimir la suma de los
números.</code></pre>
<div class="sourceCode" id="cb128"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toList ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>toList input <span class="ot">=</span> <span class="fu">read</span> (<span class="st">&quot;[&quot;</span> <span class="op">++</span> input <span class="op">++</span> <span class="st">&quot;]&quot;</span>)</span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Enter a list of numbers (separated by comma):&quot;</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>  input <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> <span class="fu">sum</span> (toList input)</span></code></pre></div>
<p>Debería ser sencillo comprender el comportamiento de este programa. Analicemos los tipos en más detalle.</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="fu">putStrLn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a><span class="fu">getLine</span><span class="ot">  ::</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span><span class="ot">    ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>O más interesante, notamos que cada expresión en el bloque <code>do</code> tiene el tipo <code>IO a</code></p>
<div class="sourceCode" id="cb130"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Enter ... &quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> ()</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  getLine               ::</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="dt">Something</span><span class="ot">       ::</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>También debemos prestar atención a los efectos del símbolo <code>&lt;-</code>.</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> something</span></code></pre></div>
<p>Si <code>something :: IO a</code> entonces <code>x :: a</code>.</p>
<p>Otra cosa importante a notar sobre usar <code>IO</code>: Todas las lineas en un bloque <code>do</code> deben ser de una de dos posibles formas:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="ot">action1             ::</span> <span class="dt">IO</span> a</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- in this case, generally a = ()</span></span></code></pre></div>
<p>O</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>value <span class="ot">&lt;-</span> action2    <span class="co">-- where</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- action2 :: IO b</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- value   :: b</span></span></code></pre></div>
<p>Estos dos tipos de linea corresponderán a dos formas diferentes de secuenciar acciones. El significado de esta sentencia debería quedar clara para el final de la siguiente sección.</p>
<p>Ahora veamos como se comporta el programa. Por ejemplo, qué ocurre si el usuario ingresa algo extraño? Intentemos:</p>
<pre><code>% runghc 02_progressive_io_example.lhs
    Enter a list of numbers (separated by comma):
    foo
    Prelude.read: no parse</code></pre>
<p>Un horrible mensaje de error y un fallo! Nuestra primera mejora será responder con un mensaje más amigable.</p>
<p>Para hacerlo, debemos detectar que algo salió mal. Aquí hay una forma de hacerlo: usar el tipo <code>Maybe</code>. Este es un tipo muy común en Haskell.</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span></code></pre></div>
<p>¿Qué es esto? <code>Maybe</code> es un tipo que toma un parámetro. Su definición es:</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span></code></pre></div>
<p>Esta es una forma muy agradable de decir que hubo un error mientras se intentaba crear/computar un valor. La función <code>maybeRead</code> es un gran ejemplo de esto. Esta es una función similar a la función <code>read</code>[^4], pero si algo sale mal el valor retornado es <code>Nothing</code>. Si el valor es correcto, retorna <code>Just &lt;el valor&gt;</code>. No intentes comprender mucho de esta función. Se usa una función de nivel menor a <code>read</code>; <code>reads</code>.</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="ot">maybeRead ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>maybeRead s <span class="ot">=</span> <span class="kw">case</span> <span class="fu">reads</span> s <span class="kw">of</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>                  [(x,<span class="st">&quot;&quot;</span>)]    <span class="ot">-&gt;</span> <span class="dt">Just</span> x</span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>                  _           <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>Ahora para estar un poco más seguros, definimos una función que va así: Si la cadena tiene el formato incorrecto, se retorna <code>Nothing</code>. Caso contrario, por ejemplo “1,2,3”, se retorna <code>Just [1,2,3]</code>.</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getListFromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Integer</span>]</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>getListFromString str <span class="ot">=</span> maybeRead <span class="op">$</span> <span class="st">&quot;[&quot;</span> <span class="op">++</span> str <span class="op">++</span> <span class="st">&quot;]&quot;</span></span></code></pre></div>
<p>Simplemente tenemos que probar el valor en nuestra función principal <code>main</code>.</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Enter a list of numbers (separated by comma):&quot;</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>  input <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> maybeList <span class="ot">=</span> getListFromString input <span class="kw">in</span></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> maybeList <span class="kw">of</span></span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Just</span> l  <span class="ot">-&gt;</span> <span class="fu">print</span> (<span class="fu">sum</span> l)</span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Bad format. Good Bye.&quot;</span></span></code></pre></div>
<p>En caso de error, mostramos un mensaje de error amigable.</p>
<p>Nótese que el tipo de cada expresión en el bloque <code>do</code> de main permanece en la forma <code>IO a</code>. La única construcción extraña es <code>error</code>. Aquí solo diré que <code>error msg</code> toma el tipo necesario (aquí <code>IO ()</code>).</p>
<p>Una cosa importante es el tipo de todas las funciones definidas hasta ahora. Solo hay una función que contiene <code>IO</code> en su tipo: <code>main</code>. Esto significa que main es impura. Pero main usa <code>getListFromString</code> que es pura. Entonces queda claro solo observando los tipos declarados que funciones son puras y cuales son impuras.</p>
<p>¿Por qué importa la pureza? Entre las muchas ventajas, aquí hay tres:</p>
<ul>
<li>Es más fácil pensar sobre una pieza de código puro que código impuro</li>
<li>La pureza te protege de los errores difícil de reproducir debido a los efectos secundarios.</li>
<li>Se pueden evaluar funciones puras en cualquier orden o en paralelo sin riesgo.</li>
</ul>
<p>Por esto se debe poner todo el código posible dentro de funciones puras.</p>
<p>Nuestra siguiente iteración será pedir al usuario una y otra vez hasta que introduzca una respuesta valida.</p>
<p>Mantenemos la primera parte:</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a><span class="ot">maybeRead ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>maybeRead s <span class="ot">=</span> <span class="kw">case</span> <span class="fu">reads</span> s <span class="kw">of</span></span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>                  [(x,<span class="st">&quot;&quot;</span>)]    <span class="ot">-&gt;</span> <span class="dt">Just</span> x</span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>                  _           <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a><span class="ot">getListFromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Integer</span>]</span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true" tabindex="-1"></a>getListFromString str <span class="ot">=</span> maybeRead <span class="op">$</span> <span class="st">&quot;[&quot;</span> <span class="op">++</span> str <span class="op">++</span> <span class="st">&quot;]&quot;</span></span></code></pre></div>
<p>Ahora creamos una función que pregunte al usuario la lista de enteros hasta que la entrada sea correcta.</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="ot">askUser ::</span> <span class="dt">IO</span> [<span class="dt">Integer</span>]</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>askUser <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Enter a list of numbers (separated by comma):&quot;</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>  input <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> maybeList <span class="ot">=</span> getListFromString input <span class="kw">in</span></span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> maybeList <span class="kw">of</span></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Just</span> l  <span class="ot">-&gt;</span> <span class="fu">return</span> l</span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> askUser</span></code></pre></div>
<p>Esta función es de tipo <code>IO [Integer]</code>. Este tipo significa que obtendremos un valor de tipo <code>[Integer]</code> a través de acciones de entrada/salida (IO). Algunas personas podrían explicar mientras sacuden las manos:</p>
<blockquote>
<p>Esto es un <code>[Integer]</code> dentro de un <code>IO</code></p>
</blockquote>
<p>Si quieres comprender los detalles detrás de todo esto, tendrás que leer la siguiente sección. Pero en realidad, si solamente quieres saber como <em>usar</em> IO solo practica un poco y recuerda pensar sobre el tipo.</p>
<p>Finalmente la función main es mucho más simple:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>  list <span class="ot">&lt;-</span> askUser</span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> <span class="fu">sum</span> list</span></code></pre></div>
<p>Hemos terminado con la introducción a la entrada/salida <code>IO</code>. Fue rápido. Estas son las principales cosas que hay que recordar.</p>
<ul>
<li><p>En el bloque <code>do</code>, cada expresión debe tener el tipo <code>IO a</code>. Así que estas limitado en el numero de expresiones disponibles. Por ejemplo, <code>getLine</code>, <code>print</code>, <code>putStrLn</code>, etc…</p></li>
<li><p>Intenta independizar las funciones puras todo lo posible.</p></li>
<li><p>El tipo <code>IO a</code> significa: una <strong>acción</strong> IO que retorna un elemento de tipo <code>a</code>. <code>IO</code> representa <em>acciones</em>; por dentro, <code>IO a</code> es el tipo de una función. Lee la siguiente sección si te da curiosidad.</p>
<p>Si practicas un poco, deberías ser capaz de usar <code>IO</code>.</p>
<p>Ejercicios: * Hacer un programa que sume todos sus argumentos. Pista: Usa la función <code>getArgs</code>.</p></li>
</ul>
<h2 id="el-truco-de-la-entradasalida-io-explicado">El truco de la entrada/salida (IO) explicado</h2>
<p><img src="../../img/haskellhard/shot12.jpg" /></p>
<p>TL;DR*:</p>
<p>Para separar las partes puras de las impuras, <code>main</code> es la función que modifica el estado del mundo exterior</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">World</span></span></code></pre></div>
<p>Una función garantiza que solo tendrá efectos secundarios si tiene este tipo. Pero observa una función <code>main</code> típica:</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>main w0 <span class="ot">=</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (v1,w1) <span class="ot">=</span> action1 w0 <span class="kw">in</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (v2,w2) <span class="ot">=</span> action2 v1 w1 <span class="kw">in</span></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (v3,w3) <span class="ot">=</span> action3 v2 w2 <span class="kw">in</span></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>    action4 v3 w3</span></code></pre></div>
<p>Tenemos varios elementos temporales (<code>w1</code>, <code>w2</code>, <code>w3</code>) que deben ser pasados a la siguiente sección.</p>
<p>Creamos una función <code>bind</code> o <code>(&gt;&gt;=)</code>. Con <code>bind</code> ya no necesitamos nombres temporales.</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>  action1 <span class="op">&gt;&gt;=</span> action2 <span class="op">&gt;&gt;=</span> action3 <span class="op">&gt;&gt;=</span> action4</span></code></pre></div>
<p>Bonus: Haskell tiene azúcar sintáctica para nosotros:</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>  v1 <span class="ot">&lt;-</span> action1</span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>  v2 <span class="ot">&lt;-</span> action2 v1</span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>  v3 <span class="ot">&lt;-</span> action3 v2</span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>  action4 v3</span></code></pre></div>
<p>Por qué usamos esta sintaxis extraña, y qué es exactamente este tipo <code>IO</code>? Parece algo mágico.</p>
<p>Por ahora vamos a olvidarnos sobre las partes puras de nuestro programa, y enfocarnos en las partes impuras.</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="ot">askUser ::</span> <span class="dt">IO</span> [<span class="dt">Integer</span>]</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>askUser <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Enter a list of numbers (separated by commas):&quot;</span></span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>  input <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> maybeList <span class="ot">=</span> getListFromString input <span class="kw">in</span></span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> maybeList <span class="kw">of</span></span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Just</span> l  <span class="ot">-&gt;</span> <span class="fu">return</span> l</span>
<span id="cb147-8"><a href="#cb147-8" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> askUser</span>
<span id="cb147-9"><a href="#cb147-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-10"><a href="#cb147-10" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb147-11"><a href="#cb147-11" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb147-12"><a href="#cb147-12" aria-hidden="true" tabindex="-1"></a>  list <span class="ot">&lt;-</span> askUser</span>
<span id="cb147-13"><a href="#cb147-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> <span class="fu">sum</span> list</span></code></pre></div>
<p>Primera cuestión remarcarle: esto parece un programa imperativo. Haskell es lo suficientemente poderoso para hacer código impuro lucir imperativo. Por ejemplo, si deseas podrías crear un <code>while</code> en Haskell. De hecho, para lidiar con entrada/salida, un estilo imperativo es generalmente más apropiado.</p>
<p>Pero deberías haber notado que esta notación es un poco inusual. Aquí el por qué, en detalle.</p>
<p>En un lenguaje imperativo el estado del mundo puede ser visto como una gran variable global oculta. Esta variable oculta es accesible por todas las funciones del lenguaje. Por ejemplo, se pude leer desde un fichero en cualquier función. Sea que el fichero exista o no es una diferencia en el posible estado que el mundo puede tomar.</p>
<p>En Haskell este estado no es oculto. Más bien, se dice <em>explicitamemten</em> que <code>main</code> es una función que puede <em>potencialmente</em> cambiar el estado del mundo. Su tipo es como:</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">World</span></span></code></pre></div>
<p>No todas las funciones pueden tener acceso a esta variable. Aquellas que tienen acceso son impuras. Funciones a las que no se les provee esta variable del mundo son puras[^5].</p>
<p>Haskell considera el estado del mundo exterior como una variable de enterada a <code>main</code>. Pero el tipo real de main es más parecido a[^6]:</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> ((),<span class="dt">World</span>)</span></code></pre></div>
<p>El tipo <code>()</code> es el tipo unitario. Nada que ver aquí.</p>
<p>Ahora escribamos nuestra función principal con esto en mente:</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a>main w0 <span class="ot">=</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (list,w1) <span class="ot">=</span> askUser w0 <span class="kw">in</span></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (x,w2) <span class="ot">=</span> <span class="fu">print</span> (<span class="fu">sum</span> list,w1) <span class="kw">in</span></span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>    x</span></code></pre></div>
<p>Primero, notamos que todas las funciones que tienen efectos secundarios deben tener el tipo:</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="dt">World</span> <span class="ot">-&gt;</span> (a,<span class="dt">World</span>)</span></code></pre></div>
<p>Donde <code>a</code> es el tipo del resultado. Por ejemplo, una función <code>getChar</code> debería tener el tipo <code>World -&gt; (Char, World)</code>.</p>
<p>Otra cosa a notar es el truco para fijar el orden de la evaluación. En Haskell, para evaluar <code>f a b</code>, tienes varias opciones:</p>
<ul>
<li>primero evaluar <code>a</code> luego <code>b</code> luego <code>f a b</code></li>
<li>primero evaluar <code>b</code> luego <code>a</code> luego <code>f a b</code></li>
<li>evaluar <code>a</code> y <code>b</code> en paralelo y luego <code>f a b</code></li>
</ul>
<p>Esto es verdad por que estamos trabajando en la parte pura del lenguaje.</p>
<p>Ahora, si tomas la función <code>main</code>, está claro que debes evaluar la primera linea antes de la segunda puesto que para evaluar la segunda linea es necesario obtener el parámetro dado en la evaluación de la primera linea.</p>
<p>Este truco funciona bien. El compilador proveerá en cada paso un puntero a un nuevo identificador del mundo real. Por dentro, <code>print</code> se evaluará como:</p>
<ul>
<li>imprimir algo en la pantalla</li>
<li>modifica el <em>id</em> del mundo exterior</li>
<li>evaluar como <code>((),new world id)</code>.</li>
</ul>
<p>Ahora, si miras el estilo de la función main, es claramente incómodo. Intentemos hacer lo mismo a la función askUser:</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="ot">askUser ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> ([<span class="dt">Integer</span>],<span class="dt">World</span>)</span></code></pre></div>
<p>Antes:</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="ot">askUser ::</span> <span class="dt">IO</span> [<span class="dt">Integer</span>]</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a>askUser <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Enter a list of numbers:&quot;</span></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>  input <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> maybeList <span class="ot">=</span> getListFromString input <span class="kw">in</span></span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> maybeList <span class="kw">of</span></span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Just</span> l  <span class="ot">-&gt;</span> <span class="fu">return</span> l</span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> askUser</span></code></pre></div>
<p>Después:</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>askUser w0 <span class="ot">=</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (_,w1)     <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;Enter a list of numbers:&quot;</span> <span class="kw">in</span></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (input,w2) <span class="ot">=</span> <span class="fu">getLine</span> w1 <span class="kw">in</span></span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (l,w3)     <span class="ot">=</span> <span class="kw">case</span> getListFromString input <span class="kw">of</span></span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">Just</span> l   <span class="ot">-&gt;</span> (l,w2)</span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> askUser w2</span>
<span id="cb154-7"><a href="#cb154-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb154-8"><a href="#cb154-8" aria-hidden="true" tabindex="-1"></a>        (l,w3)</span></code></pre></div>
<p>Esto es similar, pero incómodo. Mira todos esos nombres temporales <code>w?</code>.</p>
<p>La lección es: poner implementación <code>IO</code> en lenguajes funcionales puros es incómodo!</p>
<p>Afortunadamente, hay una mejor forma de manejar este problema. Observamos un patrón. Cada linea es de la forma:</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (y, w') <span class="ot">=</span> action x w <span class="kw">in</span></span></code></pre></div>
<p>Incluso si para alguna linea el primer argumento <code>x</code> no es necesario. La salida es de tipo tupla, <code>(answer, newWorldValue)</code>. Cada función <code>f</code> debe tener un tipo similar a:</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> (a,<span class="dt">World</span>)</span></code></pre></div>
<p>No solo eso, también podemos notar que siempre seguimos el mismo patrón de uso:</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (y,w1) <span class="ot">=</span> action1 w0 <span class="kw">in</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (z,w2) <span class="ot">=</span> action2 w1 <span class="kw">in</span></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (t,w3) <span class="ot">=</span> action3 w2 <span class="kw">in</span></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>Cada acción puede tomar de 0 a n parámetros. Y en particular, cada acción puede tomar un parámetro del resultado de la linea anterior.</p>
<p>Por ejemplo, también podríamos tener:</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (_,w1) <span class="ot">=</span> action1 x w0   <span class="kw">in</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (z,w2) <span class="ot">=</span> action2 w1     <span class="kw">in</span></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (_,w3) <span class="ot">=</span> action3 x z w2 <span class="kw">in</span></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>Y por supuesto <code>actionN w :: (World) -&gt; (a,World)</code>.</p>
<p>IMPORTANTE: Hay dos patrones importantes a considerar:</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (x,w1) <span class="ot">=</span> action1 w0 <span class="kw">in</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (y,w2) <span class="ot">=</span> action2 x w1 <span class="kw">in</span></span></code></pre></div>
<p>Y</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (_,w1) <span class="ot">=</span> action1 w0 <span class="kw">in</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (y,w2) <span class="ot">=</span> action2 w1 <span class="kw">in</span></span></code></pre></div>
<p><img src="../../img/haskellhard/shot13.jpg" /></p>
<p>Ahora, haremos un truco de magia. Haremos que el símbolo del mundo temporal “desaparezca”. Haremos un <code>bind</code> a las dos lineas. Dinamos la función <code>bind</code>. Su tipo es un poco intimidarte al principio:</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bind ::</span> (<span class="dt">World</span> <span class="ot">-&gt;</span> (a,<span class="dt">World</span>))</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> (<span class="dt">World</span> <span class="ot">-&gt;</span> (b,<span class="dt">World</span>)))</span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> (<span class="dt">World</span> <span class="ot">-&gt;</span> (b,<span class="dt">World</span>))</span></code></pre></div>
<p>Pero recuerda que <code>(World -&gt; (a,World))</code> es un tipo para una acción <code>IO</code>. Ahora renombremoslo por claridad:</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">IO</span> a <span class="ot">=</span> <span class="dt">World</span> <span class="ot">-&gt;</span> (a, <span class="dt">World</span>)</span></code></pre></div>
<p>Algunos ejemplos de funciones:</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getLine</span><span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p><code>getLine</code> es una acción <code>IO</code> que toma el mundo exterior como parámetro y retorna una tupla <code>(String,World)</code>. Esto se puede resumir como: <code>getLine</code> es de tipo <code>IO String</code>, que también vemos como una acción IO que retornará una cadena “embeded inside an IO”.</p>
<p>La función <code>print</code> también es interesante. Toma un argumento que puede ser mostrado. De hecho puede tomar dos argumentos. El primero es el valor a imprimir y el otro es el estado del mundo exterior. Luego retorna una tupla de tipo <code>((),World)</code>. Esto significa que cambia el estado del mundo exterior, pero no produce más información.</p>
<p>Este tipo nos ayuda a simplificar el tipo de <code>bind</code>:</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bind ::</span> <span class="dt">IO</span> a</span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b)</span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span></code></pre></div>
<p>Dice que <code>bind</code> toma dos acciones IO como parámetros y retorna otra acción IO.</p>
<p>Ahora, recuerda los patrones <em>importantes</em>. El primero era:</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (x,w1) <span class="ot">=</span> action1 w0 <span class="kw">in</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (y,w2) <span class="ot">=</span> action2 x w1 <span class="kw">in</span></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>(y,w2)</span></code></pre></div>
<p>Observa los tipos:</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="ot">action1  ::</span> <span class="dt">IO</span> a</span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a><span class="ot">action2  ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>(y,w2)<span class="ot">   ::</span> <span class="dt">IO</span> b</span></code></pre></div>
<p>Resulta familiar?</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a>(bind action1 action2) w0 <span class="ot">=</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (x, w1) <span class="ot">=</span> action1 w0</span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>        (y, w2) <span class="ot">=</span> action2 x w1</span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span>  (y, w2)</span></code></pre></div>
<p>La idea es esconder el argumento del mundo exterior con esta función. Hagamoslo: Como un ejemplo imagina que queremos simular:</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (line1,w1) <span class="ot">=</span> <span class="fu">getLine</span> w0 <span class="kw">in</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ((),w2) <span class="ot">=</span> <span class="fu">print</span> line1 <span class="kw">in</span></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>((),w2)</span></code></pre></div>
<p>Ahora, usando la función bind:</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a>(res,w2) <span class="ot">=</span> (bind <span class="fu">getLine</span> (\l <span class="ot">-&gt;</span> <span class="fu">print</span> l)) w0</span></code></pre></div>
<p>Como print es de tipo <code>(World -&gt; ((),World))</code>, sabemos que <code>res = ()</code> (tipo nulo). Si no te diste cuenta de la magia aquí, intentemos con tres lineas esta vez:</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (line1,w1) <span class="ot">=</span> <span class="fu">getLine</span> w0 <span class="kw">in</span></span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (line2,w2) <span class="ot">=</span> <span class="fu">getLine</span> w1 <span class="kw">in</span></span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ((),w3) <span class="ot">=</span> <span class="fu">print</span> (line1 <span class="op">++</span> line2) <span class="kw">in</span></span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a>((),w3)</span></code></pre></div>
<p>Que es equivalente a:</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a>(res,w3) <span class="ot">=</span> (bind <span class="fu">getLine</span> (\line1 <span class="ot">-&gt;</span></span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>             (bind <span class="fu">getLine</span> (\line2 <span class="ot">-&gt;</span></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>               <span class="fu">print</span> (line1 <span class="op">++</span> line2))))) w0</span></code></pre></div>
<p>Notaste algo? Si, nada de variables temporales del mundo exterior en ninguna parte! Esto es MÁGICO.</p>
<p>Podemos usar una mejor notación. Usemos <code>(&gt;&gt;=)</code> en lugar de <code>bind</code>. <code>(&gt;&gt;=)</code> es una función infijo como <code>(+)</code>; Recuerda <code>3 + 4 ⇔ (+) 3 4</code></p>
<div class="sourceCode" id="cb172"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a>(res,w3) <span class="ot">=</span> (<span class="fu">getLine</span> <span class="op">&gt;&gt;=</span></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a>           (\line1 <span class="ot">-&gt;</span> <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>           (\line2 <span class="ot">-&gt;</span> <span class="fu">print</span> (line1 <span class="op">++</span> line2)))) w0</span></code></pre></div>
<p>Haskell tiene azúcar sintáctica para nosotros:</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> action1</span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> action2</span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a>  z <span class="ot">&lt;-</span> action3</span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>Se reemplaza con:</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a>action1 <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a>action2 <span class="op">&gt;&gt;=</span> (\y <span class="ot">-&gt;</span></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a>action3 <span class="op">&gt;&gt;=</span> (\z <span class="ot">-&gt;</span></span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a>)))</span></code></pre></div>
<p>Nota que se puede usar <code>x</code> en <code>action2</code> y <code>x</code> y <code>y</code> en <code>action3</code>.</p>
<p>Pero qué pasa con las lineas que no usan <code>&lt;-</code>? Fácil, otra función <code>blindBind</code>:</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="ot">blindBind ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>blindBind action1 action2 w0 <span class="ot">=</span></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a>    bind action (\_ <span class="ot">-&gt;</span> action2) w0</span></code></pre></div>
<p>No simplifiqué esta definición por propósitos de claridad. Pero claro que podemos usar una mejor notación, usaremos el operador <code>(&gt;&gt;)</code>.</p>
<p>Y</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>    action1</span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>    action2</span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a>    action3</span></code></pre></div>
<p>Se transforma en</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a>action1 <span class="op">&gt;&gt;</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>action2 <span class="op">&gt;&gt;</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>action3</span></code></pre></div>
<p>También, otra función útil.</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="ot">putInIO ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a>putInIO x <span class="ot">=</span> <span class="dt">IO</span> (\w <span class="ot">-&gt;</span> (x,w))</span></code></pre></div>
<p>Esto es en general la forma de poner variables dentro de un “contexto de IO”. El nombre general para <code>ponerEnIO</code> es <code>return</code>. Que es un mal nombre cuando aprendes Haskell. <code>return</code> es muy distinto de lo que puedes estar acostumbrado.</p>
<p>Para finalizar, traduzcamos nuestro ejemplo:</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="ot">askUser ::</span> <span class="dt">IO</span> [<span class="dt">Integer</span>]</span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>askUser <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Enter a list of numbers (separated by commas):&quot;</span></span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a>  input <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> maybeList <span class="ot">=</span> getListFromString input <span class="kw">in</span></span>
<span id="cb179-6"><a href="#cb179-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> maybeList <span class="kw">of</span></span>
<span id="cb179-7"><a href="#cb179-7" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Just</span> l  <span class="ot">-&gt;</span> <span class="fu">return</span> l</span>
<span id="cb179-8"><a href="#cb179-8" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> askUser</span>
<span id="cb179-9"><a href="#cb179-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-10"><a href="#cb179-10" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb179-11"><a href="#cb179-11" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb179-12"><a href="#cb179-12" aria-hidden="true" tabindex="-1"></a>  list <span class="ot">&lt;-</span> askUser</span>
<span id="cb179-13"><a href="#cb179-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> <span class="fu">sum</span> list</span></code></pre></div>
<p>Se traduce a:</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a><span class="ot">maybeRead ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a>maybeRead s <span class="ot">=</span> <span class="kw">case</span> <span class="fu">reads</span> s <span class="kw">of</span></span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a>                  [(x,<span class="st">&quot;&quot;</span>)]    <span class="ot">-&gt;</span> <span class="dt">Just</span> x</span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a>                  _           <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb180-7"><a href="#cb180-7" aria-hidden="true" tabindex="-1"></a><span class="ot">getListFromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Integer</span>]</span>
<span id="cb180-8"><a href="#cb180-8" aria-hidden="true" tabindex="-1"></a>getListFromString str <span class="ot">=</span> maybeRead <span class="op">$</span> <span class="st">&quot;[&quot;</span> <span class="op">++</span> str <span class="op">++</span> <span class="st">&quot;]&quot;</span></span>
<span id="cb180-9"><a href="#cb180-9" aria-hidden="true" tabindex="-1"></a><span class="ot">askUser ::</span> <span class="dt">IO</span> [<span class="dt">Integer</span>]</span>
<span id="cb180-10"><a href="#cb180-10" aria-hidden="true" tabindex="-1"></a>askUser <span class="ot">=</span></span>
<span id="cb180-11"><a href="#cb180-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="st">&quot;Enter a list of numbers (sep. by commas):&quot;</span> <span class="op">&gt;&gt;</span></span>
<span id="cb180-12"><a href="#cb180-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> \input <span class="ot">-&gt;</span></span>
<span id="cb180-13"><a href="#cb180-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> maybeList <span class="ot">=</span> getListFromString input <span class="kw">in</span></span>
<span id="cb180-14"><a href="#cb180-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> maybeList <span class="kw">of</span></span>
<span id="cb180-15"><a href="#cb180-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> l <span class="ot">-&gt;</span> <span class="fu">return</span> l</span>
<span id="cb180-16"><a href="#cb180-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> askUser</span></code></pre></div>
<p>main :: IO () main = askUser &gt;&gt;= -&gt; print $ sum list</p>
<p>Puedes compilar este código y verificar que funciona.</p>
<p>Imagina como se vería sin el <code>(&gt;&gt;)</code> y <code>(&gt;&gt;=)</code>.</p>
<h2 id="monads">Monads</h2>
<p><img src="../../img/haskellhard/shot14.jpg" /></p>
<p>Ahora el secreto puede ser revelado: <code>IO</code> es un <em>monad</em>. Ser un monad significa que se tiene acceso a azúcar sintáctica con la notación <code>do</code>. Pero principalmente, se tiene acceso al patrón que facilitará el flujo del código.</p>
<pre><code>Aclaraciones importantes:

* Los monads no tratan necesariamente efectos secundarios!
Hay varios Monads puros.
* Los monads se tratan se secuenciar.</code></pre>
<p>En Haskell, <code>Monad</code> es una clase de tipo. Para crear una instancia de esta clase de tipo, se deben proveer las funciones <code>(&gt;&gt;=)</code> y <code>return</code>. La función <code>(&gt;&gt;)</code> se deriva de <code>(&gt;&gt;=)</code>. Aquí se muestra como la clase de tipo <code>Monad</code> está declarada (básicamente):</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m  <span class="kw">where</span></span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&gt;&gt;) ::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b</span>
<span id="cb182-6"><a href="#cb182-6" aria-hidden="true" tabindex="-1"></a>  f <span class="op">&gt;&gt;</span> g <span class="ot">=</span> f <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> g</span>
<span id="cb182-7"><a href="#cb182-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-8"><a href="#cb182-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- You should generally safely ignore this function</span></span>
<span id="cb182-9"><a href="#cb182-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- which I believe exists for historical reasons</span></span>
<span id="cb182-10"><a href="#cb182-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  fail ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m a</span>
<span id="cb182-11"><a href="#cb182-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fail</span> <span class="ot">=</span> <span class="fu">error</span></span></code></pre></div>
<pre><code>Aclaraciones:

* La palabra `class` no es tu amiga. En Haskell *class* no es una clase del
tipo que encontraras en lenguajes orientados a objetos. En Haskell una clase
tiene más bien similitudes con las interfaces de Java. Una mejor palabra
hubiera sido `typeclass`, pues eso significa un conjunto de tipos. Para que un
tipo pertenezca a una clase, todas las funciones de la clase debe ser
proporcionadas por el tipo.

* En este ejemplo en particular de clase de tipo, el tipo `m` debe ser un tipo
que tome un argumento. Por ejemplo `IO a`, pero también `Maybe a`, `[a]`,
etc...

* Para que un monad sea útil, la función debe obedecer algunas reglas. Si
tu construcción no las obedece cosas extrañas pueden ocurrir:

* Return a &gt;&gt;= k == K a m &gt;&gt;= return == m m &gt;&gt;= (-&gt; k x &gt;&gt;= h) == (m &gt;&gt;= k) &gt;&gt;=
h ~</code></pre>
<h3 id="maybe-es-un-monad">Maybe es un monad</h3>
<p>Hay varios tipos diferentes que son instancias de <code>Monad</code>. Una de las más fáciles de describir es <code>Maybe</code>. Si se tiene una secuencia de valores <code>Maybe</code>, se pueden usar monads para manipularlos. Es particularmente útil para remover construcciones <code>if..then..else..</code> profundas</p>
<p>Imagina una operación bancaria compleja. Eres candidato a ganar 700$ solo si puedes seguir una lista de operaciones sin que tu cuenta caiga hasta cero.</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a>deposit  value account <span class="ot">=</span> account <span class="op">+</span> value</span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a>withdraw value account <span class="ot">=</span> account <span class="op">-</span> value</span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a><span class="ot">eligible ::</span> (<span class="dt">Num</span> a,<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a>eligible account <span class="ot">=</span></span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> account1 <span class="ot">=</span> deposit <span class="dv">100</span> account <span class="kw">in</span></span>
<span id="cb184-7"><a href="#cb184-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> (account1 <span class="op">&lt;</span> <span class="dv">0</span>)</span>
<span id="cb184-8"><a href="#cb184-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="dt">False</span></span>
<span id="cb184-9"><a href="#cb184-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span></span>
<span id="cb184-10"><a href="#cb184-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> account2 <span class="ot">=</span> withdraw <span class="dv">200</span> account1 <span class="kw">in</span></span>
<span id="cb184-11"><a href="#cb184-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> (account2 <span class="op">&lt;</span> <span class="dv">0</span>)</span>
<span id="cb184-12"><a href="#cb184-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> <span class="dt">False</span></span>
<span id="cb184-13"><a href="#cb184-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span></span>
<span id="cb184-14"><a href="#cb184-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> account3 <span class="ot">=</span> deposit <span class="dv">100</span> account2 <span class="kw">in</span></span>
<span id="cb184-15"><a href="#cb184-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> (account3 <span class="op">&lt;</span> <span class="dv">0</span>)</span>
<span id="cb184-16"><a href="#cb184-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> <span class="dt">False</span></span>
<span id="cb184-17"><a href="#cb184-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span></span>
<span id="cb184-18"><a href="#cb184-18" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> account4 <span class="ot">=</span> withdraw <span class="dv">300</span> account3 <span class="kw">in</span></span>
<span id="cb184-19"><a href="#cb184-19" aria-hidden="true" tabindex="-1"></a>          <span class="kw">if</span> (account4 <span class="op">&lt;</span> <span class="dv">0</span>)</span>
<span id="cb184-20"><a href="#cb184-20" aria-hidden="true" tabindex="-1"></a>          <span class="kw">then</span> <span class="dt">False</span></span>
<span id="cb184-21"><a href="#cb184-21" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span></span>
<span id="cb184-22"><a href="#cb184-22" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> account5 <span class="ot">=</span> deposit <span class="dv">1000</span> account4 <span class="kw">in</span></span>
<span id="cb184-23"><a href="#cb184-23" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> (account5 <span class="op">&lt;</span> <span class="dv">0</span>)</span>
<span id="cb184-24"><a href="#cb184-24" aria-hidden="true" tabindex="-1"></a>            <span class="kw">then</span> <span class="dt">False</span></span>
<span id="cb184-25"><a href="#cb184-25" aria-hidden="true" tabindex="-1"></a>            <span class="kw">else</span></span>
<span id="cb184-26"><a href="#cb184-26" aria-hidden="true" tabindex="-1"></a>              <span class="dt">True</span></span>
<span id="cb184-27"><a href="#cb184-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-28"><a href="#cb184-28" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb184-29"><a href="#cb184-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> eligible <span class="dv">300</span> <span class="co">-- True</span></span>
<span id="cb184-30"><a href="#cb184-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> eligible <span class="dv">299</span> <span class="co">-- False</span></span></code></pre></div>
<p>Ahora, mejoremos esto usando <code>Maybe</code> y el hecho de que es un Monad</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="ot">deposit ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a>deposit value account <span class="ot">=</span> <span class="dt">Just</span> (account <span class="op">+</span> value)</span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a><span class="ot">withdraw ::</span> (<span class="dt">Num</span> a,<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a>withdraw value account <span class="ot">=</span> <span class="kw">if</span> (account <span class="op">&lt;</span> value)</span>
<span id="cb185-6"><a href="#cb185-6" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">then</span> <span class="dt">Nothing</span></span>
<span id="cb185-7"><a href="#cb185-7" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">else</span> <span class="dt">Just</span> (account <span class="op">-</span> value)</span>
<span id="cb185-8"><a href="#cb185-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-9"><a href="#cb185-9" aria-hidden="true" tabindex="-1"></a><span class="ot">eligible ::</span> (<span class="dt">Num</span> a, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Bool</span></span>
<span id="cb185-10"><a href="#cb185-10" aria-hidden="true" tabindex="-1"></a>eligible account <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb185-11"><a href="#cb185-11" aria-hidden="true" tabindex="-1"></a>  account1 <span class="ot">&lt;-</span> deposit <span class="dv">100</span> account</span>
<span id="cb185-12"><a href="#cb185-12" aria-hidden="true" tabindex="-1"></a>  account2 <span class="ot">&lt;-</span> withdraw <span class="dv">200</span> account1</span>
<span id="cb185-13"><a href="#cb185-13" aria-hidden="true" tabindex="-1"></a>  account3 <span class="ot">&lt;-</span> deposit <span class="dv">100</span> account2</span>
<span id="cb185-14"><a href="#cb185-14" aria-hidden="true" tabindex="-1"></a>  account4 <span class="ot">&lt;-</span> withdraw <span class="dv">300</span> account3</span>
<span id="cb185-15"><a href="#cb185-15" aria-hidden="true" tabindex="-1"></a>  account5 <span class="ot">&lt;-</span> deposit <span class="dv">1000</span> account4</span>
<span id="cb185-16"><a href="#cb185-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> <span class="dt">True</span></span>
<span id="cb185-17"><a href="#cb185-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-18"><a href="#cb185-18" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb185-19"><a href="#cb185-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> eligible <span class="dv">300</span> <span class="co">-- Just True</span></span>
<span id="cb185-20"><a href="#cb185-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> eligible <span class="dv">299</span> <span class="co">-- Nothing</span></span></code></pre></div>
<p>No esta nada mal, pero podemos mejorarlo más:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="ot">deposit ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>deposit value account <span class="ot">=</span> <span class="dt">Just</span> (account <span class="op">+</span> value)</span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a><span class="ot">withdraw ::</span> (<span class="dt">Num</span> a,<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a>withdraw value account <span class="ot">=</span> <span class="kw">if</span> (account <span class="op">&lt;</span> value)</span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">then</span> <span class="dt">Nothing</span></span>
<span id="cb186-7"><a href="#cb186-7" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">else</span> <span class="dt">Just</span> (account <span class="op">-</span> value)</span>
<span id="cb186-8"><a href="#cb186-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-9"><a href="#cb186-9" aria-hidden="true" tabindex="-1"></a><span class="ot">eligible ::</span> (<span class="dt">Num</span> a, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Bool</span></span>
<span id="cb186-10"><a href="#cb186-10" aria-hidden="true" tabindex="-1"></a>eligible account <span class="ot">=</span></span>
<span id="cb186-11"><a href="#cb186-11" aria-hidden="true" tabindex="-1"></a>  deposit <span class="dv">100</span> account <span class="op">&gt;&gt;=</span></span>
<span id="cb186-12"><a href="#cb186-12" aria-hidden="true" tabindex="-1"></a>  withdraw <span class="dv">200</span> <span class="op">&gt;&gt;=</span></span>
<span id="cb186-13"><a href="#cb186-13" aria-hidden="true" tabindex="-1"></a>  deposit <span class="dv">100</span>  <span class="op">&gt;&gt;=</span></span>
<span id="cb186-14"><a href="#cb186-14" aria-hidden="true" tabindex="-1"></a>  withdraw <span class="dv">300</span> <span class="op">&gt;&gt;=</span></span>
<span id="cb186-15"><a href="#cb186-15" aria-hidden="true" tabindex="-1"></a>  deposit <span class="dv">1000</span> <span class="op">&gt;&gt;</span></span>
<span id="cb186-16"><a href="#cb186-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="dt">True</span></span>
<span id="cb186-17"><a href="#cb186-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-18"><a href="#cb186-18" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb186-19"><a href="#cb186-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> eligible <span class="dv">300</span> <span class="co">-- Just True</span></span>
<span id="cb186-20"><a href="#cb186-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> eligible <span class="dv">299</span> <span class="co">-- Nothing</span></span></code></pre></div>
<p>Hemos demostrado que los Monads son una buena forma de hacer el código más elegante. Esta idea para organizar el código, en particular para <code>Maybe</code> se puede usar en la mayoría de los lenguajes imperativos. De hecho, este es más o menos el tipo de construcciones que hacemos naturalmente.</p>
<pre><code>Una aclaración importante:

El primer elemento en la secuencia evaluada a `Nothing` detendrá por
completo la evaluación. Esto significa que no se ejecutan todas las
lineas. Obtienes esto gratuitamente, gracias a la pereza (laziness).</code></pre>
<p>También se puede replicar este ejemplo con la definición de <code>(&gt;&gt;=)</code> para <code>Maybe</code> en mente:</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span>  <span class="op">&gt;&gt;=</span> _  <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Just</span> x) <span class="op">&gt;&gt;=</span> f  <span class="ot">=</span> f x</span>
<span id="cb188-5"><a href="#cb188-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-6"><a href="#cb188-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> x <span class="ot">=</span> <span class="dt">Just</span> x</span></code></pre></div>
<p>El monad <code>Maybe</code> probó ser útil en este ejemplo. Vimos la utilidad de el monad <code>IO</code>. Pero vamos por un mejor ejemplo, las listas.</p>
<h3 id="el-monad-lista">El monad lista</h3>
<p><img src="../../img/haskellhard/shot15.jpg" /></p>
<p>El monad lista ayuda a simular cómputos no determinístico:</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (guard)</span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a>allCases <span class="ot">=</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>]</span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a><span class="ot">resolve ::</span> [(<span class="dt">Int</span>,<span class="dt">Int</span>,<span class="dt">Int</span>)]</span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a>resolve <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb189-7"><a href="#cb189-7" aria-hidden="true" tabindex="-1"></a>              x <span class="ot">&lt;-</span> allCases</span>
<span id="cb189-8"><a href="#cb189-8" aria-hidden="true" tabindex="-1"></a>              y <span class="ot">&lt;-</span> allCases</span>
<span id="cb189-9"><a href="#cb189-9" aria-hidden="true" tabindex="-1"></a>              z <span class="ot">&lt;-</span> allCases</span>
<span id="cb189-10"><a href="#cb189-10" aria-hidden="true" tabindex="-1"></a>              guard <span class="op">$</span> <span class="dv">4</span><span class="op">*</span>x <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>y <span class="op">&lt;</span> z</span>
<span id="cb189-11"><a href="#cb189-11" aria-hidden="true" tabindex="-1"></a>              <span class="fu">return</span> (x,y,z)</span>
<span id="cb189-12"><a href="#cb189-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-13"><a href="#cb189-13" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb189-14"><a href="#cb189-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> resolve</span></code></pre></div>
<p>MAGIA:</p>
<pre><code>[(1,1,7),(1,1,8),(1,1,9),(1,1,10),(1,2,9),(1,2,10)]</code></pre>
<p>Para el monad lista, también hay azúcar sintáctica:</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span> <span class="op">$</span> [ (x,y,z) <span class="op">|</span> x <span class="ot">&lt;-</span> allCases,</span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a>                      y <span class="ot">&lt;-</span> allCases,</span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a>                      z <span class="ot">&lt;-</span> allCases,</span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a>                      <span class="dv">4</span><span class="op">*</span>x <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>y <span class="op">&lt;</span> z ]</span></code></pre></div>
<p>No listaré todos los monads, pero hay muchos de ellos. Usar monads simplifica la manipulación de varias nociones en lenguajes puros. En particular, los monads son muy útiles para:</p>
<ul>
<li>IO</li>
<li>Computo no determinístico</li>
<li>Generar números pseudo aleatorios</li>
<li>Mantener configuración de estado</li>
<li>Escribir estado</li>
<li>…</li>
</ul>
<p>Si me has seguido hasta aquí, entonces lo lograste! Sabes Monads[^7]!</p>
<h1 id="apéndice">Apéndice</h1>
<p>Esta sección no se trata de aprender Haskell. Solo está aquí para discutir a más profundidad algunos detalles.</p>
<h2 id="más-sobre-los-arboles-infinitos">Más sobre los arboles infinitos</h2>
<p>En la sección <em>Estructuras infinitas</em> vimos algunas construcciones simples. Desafortunadamente removimos dos propiedades de nuestro árbol:</p>
<ol type="1">
<li>No valores duplicados en los nodos</li>
<li>Árbol bien ordenado</li>
</ol>
<p>En esta sección intentaremos mantener la primera propiedad. Respecto a la segunda, debemos relajarla pero discutiremos como mantenerla todo lo posible.</p>
<p>El primer paso es crear una lista de números pseudo aleatorios:</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a>shuffle <span class="ot">=</span> <span class="fu">map</span> (\x <span class="ot">-&gt;</span> (x<span class="op">*</span><span class="dv">3123</span>) <span class="ot">`mod`</span> <span class="dv">4331</span>) [<span class="dv">1</span><span class="op">..</span>]</span></code></pre></div>
<p>Solo como recordatorio, aquí esta la definición de <code>treeFromList</code></p>
<div class="sourceCode" id="cb193"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="ot">treeFromList ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a</span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a>treeFromList []    <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>treeFromList (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Node</span> x (treeFromList (<span class="fu">filter</span> (<span class="op">&lt;</span>x) xs))</span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a>                             (treeFromList (<span class="fu">filter</span> (<span class="op">&gt;</span>x) xs))</span></code></pre></div>
<p>y <code>treeTakeDepth</code>:</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a>treeTakeDepth _ <span class="dt">Empty</span> <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a>treeTakeDepth <span class="dv">0</span> _     <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>treeTakeDepth n (<span class="dt">Node</span> x left right) <span class="ot">=</span> <span class="kw">let</span></span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a>          nl <span class="ot">=</span> treeTakeDepth (n<span class="op">-</span><span class="dv">1</span>) left</span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a>          nr <span class="ot">=</span> treeTakeDepth (n<span class="op">-</span><span class="dv">1</span>) right</span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a>          <span class="kw">in</span></span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a>              <span class="dt">Node</span> x nl nr</span></code></pre></div>
<p>Observa el resultado de:</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a>      <span class="fu">putStrLn</span> <span class="st">&quot;take 10 shuffle&quot;</span></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span> <span class="op">$</span> <span class="fu">take</span> <span class="dv">10</span> shuffle</span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">putStrLn</span> <span class="st">&quot;\ntreeTakeDepth 4 (treeFromList shuffle)&quot;</span></span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span> <span class="op">$</span> treeTakeDepth <span class="dv">4</span> (treeFromList shuffle)</span></code></pre></div>
<pre><code>% runghc 02_Hard_Part/41_Infinites_Structures.lhs
take 10 shuffle
[3123,1915,707,3830,2622,1414,206,3329,2121,913]
treeTakeDepth 4 (treeFromList shuffle)

&lt; 3123
: |--1915
: |  |--707
: |  |  |--206
: |  |  `--1414
: |  `--2622
: |     |--2121
: |     `--2828
: `--3830
:    |--3329
:    |  |--3240
:    |  `--3535
:    `--4036
:       |--3947
:       `--4242</code></pre>
<p>Bien! Termina! Pero cuidado, solo funcionará si tiene algo que poner en la rama.</p>
<p>Por ejemplo</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a>treeTakeDepth <span class="dv">4</span> (treeFromList [<span class="dv">1</span><span class="op">..</span>])</span></code></pre></div>
<p>No terminará nunca. Por que intentará acceder a la cabeza de <code>filter (&lt;1) [2..]</code>. Pero <code>filger</code> no es lo bastante inteligente para entender que el resultado es una lista vacía.</p>
<p>Aun así, es un ejemplo muy bueno de lo que los programas no estrictos pueden ofrecer.</p>
<p>Como ejercicio para el lector:</p>
<ul>
<li>Probar la existencia de un numero <code>n</code> tal que <code>treeTakeDepth n   (treeFromList shuffle)</code> entrará en un loop infinito.</li>
<li>Encontrar un limite superior para <code>n</code>.</li>
<li>Probar que no hay una lista <code>suffle</code> tal que para cualquier profundidad, el programa termina.</li>
</ul>
<p>Para resolver este problema modificaremos un poco las funciones <code>treeFromList</code> y <code>shuffle</code>.</p>
<p>Un primer problema es la falta de infinitos números diferentes en nuestra implementación de <code>shuffle</code>. Solo hemos generado <code>4331</code> números distintos. Para solucionarlo haremos una función <code>shuffle</code> mejorada.</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a>shuffle <span class="ot">=</span> <span class="fu">map</span> rand [<span class="dv">1</span><span class="op">..</span>]</span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">where</span></span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a>              rand x <span class="ot">=</span> ((p x) <span class="ot">`mod`</span> (x<span class="op">+</span>c)) <span class="op">-</span> ((x<span class="op">+</span>c) <span class="ot">`div`</span> <span class="dv">2</span>)</span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a>              p x <span class="ot">=</span> m<span class="op">*</span>x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> n<span class="op">*</span>x <span class="op">+</span> o <span class="co">-- some polynome</span></span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a>              m <span class="ot">=</span> <span class="dv">3123</span></span>
<span id="cb198-6"><a href="#cb198-6" aria-hidden="true" tabindex="-1"></a>              n <span class="ot">=</span> <span class="dv">31</span></span>
<span id="cb198-7"><a href="#cb198-7" aria-hidden="true" tabindex="-1"></a>              o <span class="ot">=</span> <span class="dv">7641</span></span>
<span id="cb198-8"><a href="#cb198-8" aria-hidden="true" tabindex="-1"></a>              c <span class="ot">=</span> <span class="dv">1237</span></span></code></pre></div>
<p>Esta función tiene la propiedad de no tener un limite superior o inferior. Pero tener una lista mejor mezclada no es suficiente para no entrar en un bucle infinito.</p>
<p>Generalmente, no podemos decidir si <code>filter (&lt;x) xs</code> está vacía. Entonces para resolver este problema, autorizaré algo de error en la creación del árbol binario. Esta nueva versión puede crear un árbol binario que no tienen la siguiente propiedad para algunos de sus nodos:</p>
<pre><code>Cualquier elemento en la rama izquierda debe ser estrictamente
inferior a la etiqueta de la raíz.</code></pre>
<p>Permanecerá en su <em>mayor parte</em> un árbol binario ordenado. Más aún, por construcción, el valor de cada nodo es único en el árbol.</p>
<p>Aquí nuestra nueva versión de <code>treeFromList</code>. Simplemente sea ha remplazado <code>filter</code> por <code>safefilter</code>.</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="ot">treeFromList ::</span> (<span class="dt">Ord</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a</span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a>treeFromList []    <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a>treeFromList (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Node</span> x left right</span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a>          <span class="kw">where</span></span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true" tabindex="-1"></a>              left <span class="ot">=</span> treeFromList <span class="op">$</span> safefilter (<span class="op">&lt;</span>x) xs</span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true" tabindex="-1"></a>              right <span class="ot">=</span> treeFromList <span class="op">$</span> safefilter (<span class="op">&gt;</span>x) xs</span></code></pre></div>
<p>Esta nueva función <code>safefilter</code> es casi equivalente a <code>filter</code> pero no entra en un bucle infinito si el resultado es una lista infinita. Si no puede encontrar un elemento para el cual la prueba resulte cierta luego de 10000 pasos consecutivos, entonces considera que es el final de la búsqueda.</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="ot">safefilter ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a>safefilter f l <span class="ot">=</span> safefilter' f l nbTry</span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>      nbTry <span class="ot">=</span> <span class="dv">10000</span></span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a>      safefilter' _ _ <span class="dv">0</span> <span class="ot">=</span> []</span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>      safefilter' _ [] _ <span class="ot">=</span> []</span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true" tabindex="-1"></a>      safefilter' f (x<span class="op">:</span>xs) n <span class="ot">=</span></span>
<span id="cb201-8"><a href="#cb201-8" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">if</span> f x</span>
<span id="cb201-9"><a href="#cb201-9" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">then</span> x <span class="op">:</span> safefilter' f xs nbTry</span>
<span id="cb201-10"><a href="#cb201-10" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">else</span> safefilter' f xs (n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<p>Ahora el programa se ejecuta bien:</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a>      <span class="fu">putStrLn</span> <span class="st">&quot;take 10 shuffle&quot;</span></span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span> <span class="op">$</span> <span class="fu">take</span> <span class="dv">10</span> shuffle</span>
<span id="cb202-4"><a href="#cb202-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">putStrLn</span> <span class="st">&quot;\ntreeTakeDepth 8 (treeFromList shuffle)&quot;</span></span>
<span id="cb202-5"><a href="#cb202-5" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span> <span class="op">$</span> treeTakeDepth <span class="dv">8</span> (treeFromList <span class="op">$</span> shuffle)</span></code></pre></div>
<p>Se debería ver que el tiempo para imprimir cada valor es diferente. Esto es por que Haskell calcula cada valor cuando lo necesita. Y en este caso, esto ocurre cuando se solicita imprimirlo en pantalla.</p>
<p>Intenta remplazar la profundidad de <code>8</code> a <code>100</code>. Funcionará sin comerse tu RAM! El flujo en el manejo de memoria es hecho de forma natural por Haskell.</p>
<p>Como ejercicio para el lector:</p>
<ul>
<li><p>Incluso con un valor grande constante para <code>deep</code> y <code>nbTry</code>, parece funcionar bien. Pero en el peor caso, puede ser exponencial. Crear una lista para el peor caso y darlo como parámetro a <code>treeFromList</code>. Pista: piensa en <code>[0,-1,-1,...,-1,1,-1,...,-1,1,...]</code>.</p></li>
<li><p>Primero intenté implementar <code>safefilter</code> como:</p></li>
</ul>
<div class="sourceCode" id="cb203"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a>safefilter' f l <span class="ot">=</span> <span class="kw">if</span> <span class="fu">filter</span> f (<span class="fu">take</span> <span class="dv">10000</span> l) <span class="op">==</span> []</span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a>            <span class="kw">then</span> []</span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a>            <span class="kw">else</span> <span class="fu">filter</span> f l</span></code></pre></div>
<p>Explica por que no funciona y puede entrar en un loop infinito.</p>
<ul>
<li>Supón que <code>shuffle</code> es una lista aleatoria real con limites crecientes. Si estudias un poco esta estructura, descubrirás que con una probabilidad de 1, esta es una estructura infinita. Usando el siguiente código encuentra una definición de <code>f</code> tal que con probabilidad de <code>1</code>, <code>treeFromList' shuffle</code> es infinita. Y pruebalo. (esto solo es una conjetura).</li>
</ul>
<div class="sourceCode" id="cb204"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a>treeFromList' []  n <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a>treeFromList' (x<span class="op">:</span>xs) n <span class="ot">=</span> <span class="dt">Node</span> x left right</span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a>        left <span class="ot">=</span> treeFromList' (safefilter' (<span class="op">&lt;</span>x) xs (f n)</span>
<span id="cb204-5"><a href="#cb204-5" aria-hidden="true" tabindex="-1"></a>        right <span class="ot">=</span> treeFromList' (safefilter' (<span class="op">&gt;</span>x) xs (f n)</span>
<span id="cb204-6"><a href="#cb204-6" aria-hidden="true" tabindex="-1"></a>        f <span class="ot">=</span> <span class="op">???</span></span></code></pre></div>
<p>[^1]. Incluso si los lenguajes mas recientes intentan ocultarlos, están presentes.</p>
<p>[^2]. Se que estoy haciendo trampa. Pero hablaré “no estricto” luego.</p>
<p>[^3]. Para los valientes, una explicación más completa del patrón de matching se puede encontrar <a href="http://www.cs.auckland.ac.nz/references/haskell/haskell-intro-html/patterns.html">aquí</a>.</p>
<p>[^4]. Es muy similar al <code>eval</code> de javascript en una cadena que contiene JSON.</p>
<p>[^5]. Hay algunas excepciones <em>no seguras</em> ha esta regla. Pero no deberías ver su uso en una aplicación real excepto tal vez para propósitos de depuración.</p>
<p>[^6]. Para los curiosos el tipo real es <code>data IO a = IO {unIO :: State# RealWorld -&gt; (#State# RealWorld, a #)}</code>. Los ‘#’ tienen que ver con la optimización.</p>
<p>[^7]. Ciertamente necesitas practicar un poco para acostumbrarte a ellos y entender cuando los puedes usar y crearlos tu mismo. Pero ya haz hecho un gran avance.</p>
    </section>
</article>

            </div>
        </div>

    </body>

</html>
