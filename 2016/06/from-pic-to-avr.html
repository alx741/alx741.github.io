<!doctype html>
<html lang="en">
    <head>
        <title>Silly Bytes</title>

        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="Software & Hardware Hacking Blog - vim,haskell,firmware,stm32,linux,ratpoision and more">

        <link rel="shortcut icon" type="image/png" href="../../img/favicon.png" />
        <link rel="stylesheet" href="../../css/main.css" />
    </head>


    <body>

        <header>

    <nav class="navbar">
        <div class="navbar-brand">
            <a class="navbar-item" href="../../index.html">
                <b id="logo">Silly Bytes</b>
            </a>
        </div>

        <div id="sillybytesnavbar" class="navbar-menu">
            <div class="navbar-end">
                <a href="../../index.html" class="navbar-item">Home</a>
                <a href="../../about.html" class="navbar-item">About</a>
            </div>
        </div>
    </nav>

</header>


        <div id="main" class="container is-max-desktop">
            <div class="container is-fluid">
                <article class="post">
    <h1 class="is-size-2 has-text-weight-medium has-text-left">From PIC to AVR</h2>
    <aside class="date has-text-left">June 17, 2016</aside>

    <section id="post-content">
        <p>This is my humble contribution to the <em>PIC vs AVR holy war</em>.</p>
<p>TL;DR: I was previously a PIC user but decided I hate it, switched to AVR and
love it!</p>
<p><a href="https://en.wikipedia.org/wiki/PIC_microcontroller">PIC</a> from Microchip and
<a href="https://en.wikipedia.org/wiki/Atmel_AVR">AVR</a> from Atmel are both wonderful
families of microcontrollers for the hobbyist and professional as well. I’m
going to argue, however, that AVR is overall better for every purpose and
because of multiple reasons.</p>
<!--more-->
<h1 id="hardware">Hardware</h1>
<p>I’m referring to programming/flashing hardware here. The only feasible way I
currently have to program PIC uCs is by using my <a href="https://sillybytes.net/2013/08/programando-pics-en-gnulinux-hardware-y.html">parallel port PIC
programmer</a>
and the almost forgotten at this point, though amazing <em>Odyssey</em> software.</p>
<p>The only feasible way you say? Yes!, at the time of writing, getting a PICkit (2
or 3) requires at least a $100+ (USD) budget. Any other solution like PICkit
clones are not much cheaper either. Not at all a reasonable budget for the 3rd
world hobbyist.</p>
<p>Using a Microchip’s PICkit (or a clone) requires using the <em>pk2cmd</em>
<strong>privative</strong> software, which means that doing anything outside MPLAB is a major
PITA.</p>
<p>AVR on the other hand, lets you flash chips so easily and for so cheap!, A DAPA
(or DASA) programmer is simple, inexpensive and fast. Both the USBTiny and the
USBASP programmers are readily available at reasonable prices online and can be
used with the <em>avrdude</em> CLI tool, a much welcomed improvement over MPLAB
behemoth.</p>
<h1 id="software">Software</h1>
<h2 id="programming">Programming</h2>
<p>Yes, Microchip provides a complete, fully compatible IDE (MPLAB) that can run in
Unix* systems and can talk to PICkit. <a href="https://sillybytes.net/2016/03/why-do-i-hate-ides.htm">But using an IDE pains
me</a>, and using
<strong>privative</strong> software that only works with <strong>privative</strong> hardware pains me even
more.</p>
<p>I want a Free Software (as in Freedom) command line tool to drive a reasonably
priced programmer hardware. The <em>Odyssey</em> utility that I’ve mentioned is a
blessing!, but getting (Free) software for a Serial programmer, a PICkit or a
PICkit clone is impossible, nobody cares about PIC Free tooling, just go and use
all the privative, restrictive stuff that Microchip forces onto you.</p>
<p><em>Avrdude</em> solves everything. A unified (GPL) tool that can drive any programmer
with any hardware interface. I absolutely love it!</p>
<h2 id="compiler">Compiler</h2>
<p>The same problem here, Microchip provides a freeware (privative) compiler –that
goes as far as to restrict some optimizations for the freeware user– and the
only sane way to use it is through the bloated IDE.</p>
<p>The <a href="http://sdcc.sourceforge.net/">SDCC</a> compiler solves this. Kind of… Look I
really like SDCC, it’s an excellent Free Software compiler, but the PIC port is
not that good (yet?), it still requires you to use non-free Microchip’s header
files and linker mappings.</p>
<p>With AVR, you get to use the <em>GCC</em> port. Yes that’s right, the GNU freaking C
compiler! And you also get a fully featured GPL
<a href="http://www.nongnu.org/avr-libc/">avr-libc</a> on top of that.</p>
<h1 id="community">Community</h1>
<p>I’ve always struggled to find help with PIC. Sure there is a lot out there,
Microchip’s official documentation is very good and professional, but even in
Microchip’s own forums you’re not able to get the level of community help you
can get from AVR’s community.</p>
<p>AVR has a hacker/hobbyist/professional Free Software and Open Hardware
centered community that makes it so much better overall.</p>
<h1 id="conclusion">Conclusion</h1>
<p>For me PIC is horrible mostly because I dislike IDE’s and prefer to use CLI
tools that I can easily script with, adapt to powerful text editors, run on
remote machines over network and so on. I acknowledge, however, that many
developers feel the opposite way and dislike the command line interface and/or
couldn’t live without an IDE, so the reasons I don’t like PIC and love AVR might
be the same reasons why you love PIC instead.</p>
<p>It’s all about <strong>tooling</strong>. When I say “I don’t like PIC”, what I really mean
is: “I don’t like PIC’s <strong>tooling</strong>”. Both PIC and AVR have extremely powerful
and comparable hardware. I do like the <strong>devices</strong> from both of them.</p>
    </section>
</article>

            </div>
        </div>

    </body>

</html>
